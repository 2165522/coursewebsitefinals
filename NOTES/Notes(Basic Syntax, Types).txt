BASIC SYNTAX

PHP tags
	- When PHP parses a file, it looks for opening and closing tags, which are <?php and ?> which tell PHP to start and stop interpreting the code between them.
	- If pure PHP code it is preferable to used the PHP closing tag, this will prevents accidental whitespace or new lines being added after the PHP closing tag. Causing different effects because PHP will start output buffering when there is no intention from the programmer to send and output at that point in the script.

<?php
 echo "Hello World";

//... more code

 echo "last Statement";

// the script ends here with no PHP closing tag

========================================================================
Escaping from HTML

<p>This is going to be ignored by PHP and displayed by the browser. </p>

<?php echo 'While this is going to be parsed.';?>

<p> This will also be ignored by PHP and displayed by the browser. </p>

	- when the PHP interpreter hits the ?> closing tags, it simply starts outputting whatever it finds until it hits another opening tag unless in the middle of a conditional statement in which case the interpreter will determine the outcome of the conditional before making a decision of what to skip over.

	Advanced escaping using conditions
		<?php if ($expression == true): ?>
  			This will show if the expression is true.
		<?php else: ?>
  			Otherwise this will show.
		<?php endif; ?>
	
	- PHP will skip the blocks where the condition is not met. PHP skips them according to the condition since the PHP interpreter will jump over blocks contained within a condition that is not met.

	- In PHP 5, there are up to five different pairs of opening and closing tags available in PHP, depending on how PHP is configured. Two of these, <?php ?> and <script language="php"> </script>, are always available. There is also the short echo tag <?= ?>, which is always available in PHP 5.4.0 and later.

*Also note that if you are embedding PHP within XML or XHTML you will need to use the <?php ?> tags to remain compliant with standards.

	-PHP 7 removes support for ASP tags and <script language="php"> tags. As such, we recommend only using <?php ?> and <?= ?> when writing PHP code to maximise compatibility.

1.  <?php echo 'if you want to serve PHP code in XHTML or XML documents,
                use these tags'; ?>

2.  You can use the short echo tag to <?= 'print this string' ?>.
    It's always enabled in PHP 5.4.0 and later, and is equivalent to
    <?php echo 'print this string' ?>.

3.  <? echo 'this code is within short tags, but will only work '.
            'if short_open_tag is enabled'; ?>

4.  <script language="php">
        echo 'some editors (like FrontPage) don\'t
              like processing instructions within these tags';
    </script>
    This syntax is removed in PHP 7.0.0.

5.  <% echo 'You may optionally use ASP-style tags'; %>
    Code within these tags <%= $variable; %> is a shortcut for this code <% echo $variable; %>
    Both of these syntaxes are removed in PHP 7.0.0.

	- ASP style tags (example five) are only available when they are enabled via the asp_tags php.ini configuration file directive, and have been removed in PHP 7.0.0.

*Using short tags should be avoided when developing applications or libraries that are meant for redistribution, or deployment on PHP servers which are not under your control, because short tags may not be supported on the target server. For portable, redistributable code, be sure not to use short tags.

========================================================================
Instruction Separation

	- You do not need to used a semicolon to terminating the last line of a PHP block. The closing tag for the block will include the immediately trailing newline if one is present.

<?php
    echo 'This is a test';
?>

<?php echo 'This is a test' ?>

<?php echo 'We omitted the last closing tag';

*Using a closing tag is optional but and some cases this is helpful when usung include or require, so unwanted whitespace will not occur at the end of files, and you will still be able to add headers to the response later.

========================================================================
Comments

<?php
    echo 'This is a test'; // This is a one-line c++ style comment
    /* This is a multi line comment
       yet another line of comment */
    echo 'This is yet another test';
    echo 'One Final Test'; # This is a one-line shell-style comment
?>

	-The “one-l ine” comment style remarks only PHP codes either the current block or the end of the line, whichever comes first, meaning HTML code with // … ?> or # … ?> before them will be printed; having ?> on the other hand breaks out PHP mode returning it to HTML mode while // or # doesn’t affect it. The asp_tags configuration directive acts the same with // %> and # %> when being enabled but the </script> tag cannot break out PHP mode in a one-line comment.

====================================================================================================================================================

TYPES

Introduction

PHP supports ten primitive types. 

Four Scalar types:

	- boolean
		- Considered as the simplest type in which it only gives a correct value whether it’s TRUE or FALSE.

	SYNTAX
	<?php
	$foo = True; // assign the value TRUE to $foo
	?>
	
	Converting to Boolean 
		- In converting a value to boolean, (bool) or (boolean) casts is being used but sometimes the cast is dispensable because the value will be converted right away by an operator or control structure requiring a boolean argument.

		- When converting to boolean, the following values are considered FALSE:

			- the boolean FALSE itself
			- the integer 0 (zero)
			- the float 0.0 (zero)
			- the empty string, and the string "0"
			- an array with zero elements
			- the special type NULL (including unset variables)
			- SimpleXML objects created from empty tags
			- Every other value is considered TRUE (including any resource and NAN).

	*-1 is considered TRUE, like any other non-zero (whether negative or positive) number!

-----------------------------------------------------------------------------------------------------------------------------------------------------

	- integer

Syntax
	- Different types of integers are as follows:

Decimal – base 10
Hexadecimal – base 16, begin the number with 0x in using this notation
Octal – base 8, begin the number with 0 in using this notation
Binary – base 2, begin the number with 0b in using this notation

Can also be preceded by a sign (- or +).

	Integer literals

	<?php
	$a = 1234; // decimal number
	$a = -123; // a negative number
	$a = 0123; // octal number (equivalent to 83 decimal)
	$a = 0x1A; // hexadecimal number (equivalent to 26 decimal)
	$a = 0b11111111; // binary number (equivalent to 255 decimal)
	?>

Formally, the structure for integer literals is:

decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

binary      : 0[bB][01]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
            | [+-]?binary

Integer Overflow

	- Number that exceeds the integer type experienced by the PHP will be interpreted as a float likewise with the operation having a number beyond the bounds of the integer type will return a float.

Integer overflow on a 32-bit system

	<?php
	$large_number = 2147483647;
	var_dump($large_number);                     // int(2147483647)

	$large_number = 2147483648;
	var_dump($large_number);                     // float(2147483648)

	$million = 1000000;
	$large_number =  50000 * $million;
	var_dump($large_number);                     // float(50000000000)
	?>	

Integer overflow on a 64-bit system

	<?php
	$large_number = 9223372036854775807;
	var_dump($large_number);                     // int(9223372036854775807)

	$large_number = 9223372036854775808;
	var_dump($large_number);                     // float(9.2233720368548E+18)

	$million = 1000000;
	$large_number =  50000000000000 * $million;
	var_dump($large_number);                     // float(5.0E+19)
	?>

		- There is no integer division operator in PHP. 1/2 yields the float 0.5. The value can be casted to an integer to round it towards zero, or the round() function provides finer control over rounding.

Converting to Integer

	From booleans 
		FALSE will yield 0 (zero), and TRUE will yield 1 (one).

	From floating point numbers 
		When converting from float to integer, the number will be rounded towards zero.

	- CCasts such as (int) or (integer) is used when converting a value to integer but in some parts of it, cast is not necessary because the value will automatically be converted when an operator requires an integer argument. Intval() function can converts a value to integer also.
If a resource is converted to an integer, then the result will be the unique resource number assigned to the resource by PHP at runtime.

*Never cast an unknown fraction to integer, as this can sometimes lead to unexpected results.

<?php
echo (int) ( (0.1+0.7) * 10 ); // echoes 7!
?>

--------------------------------------------------------------------------------------------------------------------------------------------------

- float (floating-point number, aka double)
		- Floating point numbers which are also known as "floats", "doubles", or "real numbers" can be classified using any of the following syntaxes:
			<?php
			$a = 1.234; 
			$b = 1.2e3; 
			$c = 7E-10;
				?>
	Formally:

		LNUM          [0-9]+
		DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
		EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})

	- The size of a float is platform-dependent, although a maximum of ~1.8e308 with a precision of roughly 14 decimal digits is a common value (the 64 bit IEEE format).

	Converting to float
		- Other types of values conversion is being done by converting first the value to integer then to float. As of PHP 5, a notice is thrown if an object is converted to float.

	Comparing Float
		- Equality is difficult to be done sometimes with testing floating point values because of how it is being illustrated internally but knowing the differentiation of floating point values that works around these limitations has a way.

		- In testing the floating point values for equality, upper bound on the relative error due to rounding known as the machine epsilon or unit roundoff used, making it as the smallest acceptable difference in calculations.

		$a and $b are equal to 5 digits of precision.

			<?php
			$a = 1.23456789;
			$b = 1.23456780;
			$epsilon = 0.00001;

			if(abs($a-$b) < $epsilon) {
			    echo "true";
			}
			?>

	Nan
	- Some numeric operations can result in a value represented by the constant NAN. This result represents an undefined value in floating-point calculations. Any loose or strict comparisons of this value against any other value, including itself, but except TRUE, will have a result of FALSE.

	- NAN represents any number of different values and should not be compared to other values, including itself instead it should be checked for using is_nan().

----------------------------------------------------------------------------------------------------------------------------------------------------
	- string(not done)
		-A string is series of characters, where a character is the same as a byte. This means that PHP only supports a 256-character set, and hence does not offer native Unicode support.
	SYNTAX
		- single quoted
		- double quoted
		- heredoc syntax
		- nowdoc syntax 

-----------------------------------------------------------------------------------------------------------------------------------------------------

Four compound types:	
	- array(not done)
--------------------------------------------------------------------------------------------------------------------------------------------------

	- object
		- To create a new object, use the new statement to instantiate a class:
	<?php
	class foo
	{
   	 function do_foo()
    	{
        echo "Doing foo."; 
    	}
	}

	$bar = new foo;
	$bar->do_foo();
	?>
Converting to object
	- Object to Object – Not modified
	- Value of any other type to Object – instance of the stdClass built-in class created
	- NULL – instance is Empty
	- Array that is being transformed to an object having properties named by keys and corresponding values, with the exception of numeric keys which will be inaccessible unless iterated.

	<?php
	$obj = (object) array('1' => 'foo');
	var_dump(isset($obj->{'1'})); // outputs 'bool(false)'
	var_dump(key($obj)); // outputs 'int(1)'
	?>

For any other value, a member variable named scalar will contain the value.

	<?php
	$obj = (object) 'ciao';
	echo $obj->scalar;  // outputs 'ciao'
	?>	
--------------------------------------------------------------------------------------------------------------------------------------------------

	- callable

--------------------------------------------------------------------------------------------------------------------------------------------------
	- iterable
		- A pseudo- type established in PHP 7.1 that takes any array or object implementing the Traversable interface in which this two are iterable using foreach and can be utilized with yield from within a generator.

	Using Iterables 
		-Iterables as a parameter can be a great help specially in knowing that a particular function needs a set of values but a part of it does not give much attention about the form of the value set because it will be utilized with foreach. A TypeError will be thrown if a value is not an array or instance.

Iterable parameter type example
	<?php

	function foo(iterable $iterable) {
    		foreach ($iterable as $value) {
        	// ...
    		} 
	}

	?>

Iterable parameter default value example
	<?php

	function foo(iterable $iterable = []) {
    		// ...
	}

	?>

Iterable can also be used as a return type to indicate a function will return an iterable value. If the returned value is not an array or instance of Traversable, a TypeError will be thrown.

Iterable return type example 
	<?php

	function bar(): iterable {
    		return [1, 2, 3];
	}

	?>

Functions declaring iterable as a return type may also be generators.

Iterable generator return type example
	<?php

	function gen(): iterable {
    		yield 1;
    		yield 2;
	    	yield 3;
	}

	?>

Iterable Type Variance

	- Classes extending or implementing may broaden methods using array or Traversable as parameter types to iterable or narrow return types from iterable to array or Traversable.

Iterable type variance example

	<?php

	interface Example {
    		public function method(array $array): iterable;
	}

	class ExampleImplementation implements Example {
    		public function method(iterable $iterable): array {
        		// Parameter broadened and return type narrowed.
    		}
	}

	?>

=================================================================================================================================================
And Finally two special types:

	- resource 
		-Considered as a special variable holding a reference to an external resource, that are created and used by special functions.

Converting to resource
	- As resource variables hold special handles to opened files, database connections, image canvas areas and the like, converting to a resource makes no sense.

Freeing Resources
	- A resource with no more references to it is detected automatically, and it is freed by the garbage collector. For this reason, it is rarely necessary to free the memory manually with the help of reference- counting system.
-------------------------------------------------------------------------------------------------------------------------------------------------
	- NULL
		- It represents a variable having no value and the only possible value of type null.

	Variable that is null to be considered are as follows:
		- it has been assigned the constant NULL.
		- it has not been set to any value yet.
		- it has been unset().

Syntax
	- There is only one value of type null, and that is the case-insensitive constant NULL.
	
	<?php
	$var = NULL;       
	?>

Casting to Null
	- Casting a variable to null using (unset) $var will not remove the variable or unset its value. It will only return a NULL value.

==================================================================================================================================================
This manual also introduces some pseudo-types for readability reasons:

	- mixed
	- number
	- callback (aka callable)
	- array| object
	- void

And the pseudo-variable $ ....

	- Some References to the type " double " may remain in the manual. Consider double the same as float.

*Note: To check the type and value of an expression, use the var_dump() function.

To get a human-readable representation of a type for debugging, use the gettype() function. To check for a certain type, do not use gettype(), but rather the is_type functions. Some examples:

<?php
$a_bool = TRUE;   // a boolean
$a_str  = "foo";  // a string
$a_str2 = 'foo';  // a string
$an_int = 12;     // an integer

echo gettype($a_bool); // prints out:  boolean
echo gettype($a_str);  // prints out:  string

// If this is an integer, increment it by four
if (is_int($an_int)) {
    $an_int += 4;
}

// If $a_bool is a string, print it out
// (does not print out anything)
if (is_string($a_bool)) {
    echo "String: $a_bool";
}
?>

(not done)
=========================================================================

