ASSERTION TESTING 

	Class: assert.AssertionError
		A subclass of Error that indicates the failure of an assertion.  All errors thrown by the assert module will be instances of the AssertionError class.

	new assert.AssertionError(options)

	- options <Object>
		- message <string> = error message is going to be set to this value.
	- actual <any> =  actual property on the error instance is going to contain this value.
	- expected <any> = expected property on the error instance is going to contain this value.
	- operator <string> = used to indicate what operation was used for comparison.
	- stackStartFn <function> = If provided, the generated stack trace is going to remove all frames up to the provided function.

All instances contain the built-in Error properties (message and name) and:
	- actual <any> = Set to the actual value in case 
 	Example
		assert.strictEqual()
	- expected <any> = Set to the expected value in case 
	Example
		assert.strictEqual()
	- generatedMessage <boolean> = Indicates if the message was auto-generated (true) or not.
	- code <string> This is always set to the string ERR_ASSERTION to indicate that the error is actually an assertion error.
	- operator <string> Set to the passed in operator value.

Sample Code
	
	const assert = require('assert');

// Generate an AssertionError to compare the error message later:
const { message } = new assert.AssertionError({
  actual: 1,
  expected: 2,
  operator: 'strictEqual'
});

// Verify error output:
try {
  assert.strictEqual(1, 2);
} catch (err) {
  assert(err instanceof assert.AssertionError);
  assert.strictEqual(err.message, message);
  assert.strictEqual(err.name, 'AssertionError [ERR_ASSERTION]');
  assert.strictEqual(err.actual, 1);
  assert.strictEqual(err.expected, 2);
  assert.strictEqual(err.code, 'ERR_ASSERTION');
  assert.strictEqual(err.operator, 'strictEqual');
  assert.strictEqual(err.generatedMessage, true);
}

Strict mode
	- When using the strict mode, any assert function will use the equality used in the strict function mode. So assert.deepEqual() will, for example, work the same as assert.deepStrictEqual().

	- On top of that, error messages which involve objects produce an error diff instead of displaying both objects. That is not the case for the legacy mode.

Sample Code

const assert = require('assert').strict;

Example error diff (the expected, actual, and Lines skipped will be on a single row):

Sample code

const assert = require('assert').strict;

assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]);
AssertionError [ERR_ASSERTION]: Input A expected to deepStrictEqual input B:
+ expected
- actual
... Lines skipped

  [
    [
...
      2,
-     3
+     '3'
    ],
...
    5
  ]
	
Legacy mode
	- The Abstract Equality Comparison will be used for any function without "strict" in its name, such as assert.deepEqual().

	Sample code 
		onst assert = require('assert');
	
	assert(value[, message])#
	Added in: v0.5.9
		- value <any>
		- message <any>
	An alias of assert.ok().
	
	assert.deepEqual(actual, expected[, message])#
	
		- actual <any>
		- expected <any>
		- message <any>
	Strict mode

	An alias of assert.deepStrictEqual().
	
	"Deep" equality means that the enumerable "own" properties of child objects are evaluated also:
	
	Sample code
	
	const assert = require('assert');

	const obj1 = {
		a: {
		b: 1
		}
	};
const obj2 = {
  a: {
    b: 2
  }
};
const obj3 = {
  a: {
    b: 1
  }
};
const obj4 = Object.create(obj1);

assert.deepEqual(obj1, obj1);
// OK, object is equal to itself

assert.deepEqual(obj1, obj2);
// AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } }
// values of b are different

assert.deepEqual(obj1, obj3);
// OK, objects are equal

assert.deepEqual(obj1, obj4);
// AssertionError: { a: { b: 1 } } deepEqual {}
// Prototypes are ignored
	
	- If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.deepStrictEqual(actual, expected[, message])#

		- actual <any>
		- expected <any>
		- message <any>

	Tests for deep equality between the actual and expected parameters. "Deep" equality means that the enumerable "own" properties of child objects are recursively evaluated also by the following rules.
	
	Comparison details
	
	- Primitive values are compared using the SameValue Comparison, used by Object.is().
	- Type tags of objects should be the same.
[[Prototype]] of objects are compared using the Strict Equality Comparison.
	- Only enumerable "own" properties are considered.
Error names and messages are always compared, even if these are not enumerable properties.
	- Enumerable own Symbol properties are compared as well.
	- Object wrappers are compared both as objects and unwrapped values.
	- Object properties are compared unordered.
	- Map keys and Set items are compared unordered.
	- Recursion stops when both sides differ or both sides encounter a circular reference.
	- WeakMap and WeakSet comparison does not rely on their values. See below for further details.
	
	Sample code
	
const assert = require('assert').strict;

assert.deepStrictEqual({ a: 1 }, { a: '1' });
// AssertionError: { a: 1 } deepStrictEqual { a: '1' }
// because 1 !== '1' using SameValue comparison

// The following objects don't have own properties
const date = new Date();
const object = {};
const fakeDate = {};
Object.setPrototypeOf(fakeDate, Date.prototype);

assert.deepStrictEqual(object, fakeDate);
// AssertionError: {} deepStrictEqual Date {}
// Different [[Prototype]]

assert.deepStrictEqual(date, fakeDate);
// AssertionError: 2017-03-11T14:25:31.849Z deepStrictEqual Date {}
// Different type tags

assert.deepStrictEqual(NaN, NaN);
// OK, because of the SameValue comparison

assert.deepStrictEqual(new Number(1), new Number(2));
// Fails because the wrapped number is unwrapped and compared as well.
assert.deepStrictEqual(new String('foo'), Object('foo'));
// OK because the object and the string are identical when unwrapped.

assert.deepStrictEqual(-0, -0);
// OK
assert.deepStrictEqual(0, -0);
// AssertionError: 0 deepStrictEqual -0

const symbol1 = Symbol();
const symbol2 = Symbol();
assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol1]: 1 });
// OK, because it is the same symbol on both objects.
assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol2]: 1 });
// Fails because symbol1 !== symbol2!

const weakMap1 = new WeakMap();
const weakMap2 = new WeakMap([[{}, {}]]);
const weakMap3 = new WeakMap();
weakMap3.unequal = true;

assert.deepStrictEqual(weakMap1, weakMap2);
// OK, because it is impossible to compare the entries
assert.deepStrictEqual(weakMap1, weakMap3);
// Fails because weakMap3 has a property that weakMap1 does not contain!
	
	- If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.doesNotReject(block[, error][, message])#
	
	Added in: v10.0.0
		- block <Function> | <Promise>
		- error <RegExp> | <Function>
		- message <any>

	- Awaits the block promise or, if block is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected.
	
	- If block is a function and it throws an error synchronously, assert.doesNotReject() will return a rejected Promise with that error. If the function does not return a promise, assert.doesNotReject() will return a rejected Promise with an ERR_INVALID_RETURN_VALUE error. In both cases the error handler is skipped.
	
	Besides the async nature to await the completion behaves identically to assert.doesNotThrow().
	
	Sample code
	
(async () => {
  await assert.doesNotReject(
    async () => {
      throw new TypeError('Wrong value');
    },
    SyntaxError
  );
})();
assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
  .then(() => {
    // ...
  });
	
	assert.doesNotThrow(block[, error][, message])#

		- block <Function>
		- error <RegExp> | <Function>
		- message <any>
	
	- Please note: Using assert.doesNotThrow() is actually not useful because there is no benefit by catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible.

	- When assert.doesNotThrow() is called, it will immediately call the block function.

	- If an error is thrown and it is the same type as that specified by the error parameter, then an AssertionError is thrown. If the error is of a different type, or if the error parameter is undefined, the error is propagated back to the caller.
	
	The following, for instance, will throw the TypeError because there is no matching error type in the assertion:
	
	Sample code

assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  SyntaxError
);

	However, the following will result in an AssertionError with the message 'Got unwanted exception (TypeError)..':
	
	Sample code

assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  TypeError
);

	If an AssertionError is thrown and a value is provided for the message parameter, the value of message will be appended to the AssertionError message:
	
	Sample code

assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  /Wrong value/,
  'Whoops'
);
// Throws: AssertionError: Got unwanted exception (TypeError). Whoops

	assert.equal(actual, expected[, message])#

	Added in: v0.1.21
		- actual <any>
		- expected <any>
		- message <any>
	
	Strict mode
		
		An alias of assert.strictEqual().
		
	Legacy mode
	
		Stability: 0 - Deprecated: Use assert.strictEqual() instead.
	
	Tests shallow, coercive equality between the actual and expected parameters using the Abstract Equality Comparison ( == ).
	
	Sample code

const assert = require('assert');

assert.equal(1, 1);
// OK, 1 == 1
assert.equal(1, '1');
// OK, 1 == '1'

assert.equal(1, 2);
// AssertionError: 1 == 2
assert.equal({ a: { b: 1 } }, { a: { b: 1 } });
// AssertionError: { a: { b: 1 } } == { a: { b: 1 } }

AssertionError will be thrown if the values are not equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.fail([message])#
	
	Added in: v0.1.21
		- message <any> Default: 'Failed'
	
	- Throws an AssertionError with the provided error message or a default error message. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	Sample code
	
const assert = require('assert').strict;

assert.fail();
// AssertionError [ERR_ASSERTION]: Failed

assert.fail('boom');
// AssertionError [ERR_ASSERTION]: boom

assert.fail(new TypeError('need array'));
// TypeError: need array

	assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])#

		- actual <any>
		- expected <any>
		- message <any>
		- operator <string> Default: '!='
		- stackStartFunction <Function> Default: assert.fail
	
	- If message is falsy, the error message is set as the values of actual and expected separated by the provided operator. If just the two actual and expected arguments are provided, operator will default to '!='. If message is provided as third argument it will be used as the error message and the other arguments will be stored as properties on the thrown object. If stackStartFunction is provided, all stack frames above that function will be removed from stacktrace (see Error.captureStackTrace). If no arguments are given, the default message Failed will be used.
	
	Sample code
	
const assert = require('assert').strict;

assert.fail('a', 'b');
// AssertionError [ERR_ASSERTION]: 'a' != 'b'

assert.fail(1, 2, undefined, '>');
// AssertionError [ERR_ASSERTION]: 1 > 2

assert.fail(1, 2, 'fail');
// AssertionError [ERR_ASSERTION]: fail

assert.fail(1, 2, 'whoops', '>');
// AssertionError [ERR_ASSERTION]: whoops

assert.fail(1, 2, new TypeError('need array'));
// TypeError: need array

	assert.ifError(value)#

		- value <any>
		
	- Throws value if value is not undefined or null. This is useful when testing the error argument in callbacks.
	
	Sample code
	
const assert = require('assert').strict;

assert.ifError(null);
// OK
assert.ifError(0);
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
assert.ifError('error');
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'
assert.ifError(new Error());
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error
	
	
	assert.notDeepEqual(actual, expected[, message])
	
		- actual <any>
		- expected <any>
		- message <any>

	Strict mode
		An alias of assert.notDeepStrictEqual().
		
	Legacy mode
		Deprecated: Use assert.notDeepStrictEqual() instead.

	- Tests for any deep inequality. Opposite of assert.deepEqual().
	
	Sample code

const assert = require('assert');

const obj1 = {
  a: {
    b: 1
  }
};
const obj2 = {
  a: {
    b: 2
  }
};
const obj3 = {
  a: {
    b: 1
  }
};
const obj4 = Object.create(obj1);

assert.notDeepEqual(obj1, obj1);
// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

assert.notDeepEqual(obj1, obj2);
// OK: obj1 and obj2 are not deeply equal

assert.notDeepEqual(obj1, obj3);
// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

assert.notDeepEqual(obj1, obj4);
// OK: obj1 and obj4 are not deeply equal

	assert.notDeepStrictEqual(actual, expected[, message])#

		- actual <any>
		- expected <any>
		- message <any>

	- Tests for deep strict inequality. Opposite of assert.deepStrictEqual().
	
	Sample code

const assert = require('assert').strict;

assert.notDeepStrictEqual({ a: 1 }, { a: '1' });
// OK

	- If the values are deeply and strictly equal, an AssertionError is thrown. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.notEqual(actual, expected[, message])
	
	Added in: v0.1.21
		- actual <any>
		- expected <any>
		- message <any>
	
	Strict mode
		An alias of assert.notStrictEqual().

	Legacy mode
		Use assert.notStrictEqual() instead.
		
	Tests shallow, coercive inequality with the Abstract Equality Comparison ( != ).
	
	Sample code
	
const assert = require('assert');

assert.notEqual(1, 2);
// OK

assert.notEqual(1, 1);
// AssertionError: 1 != 1

assert.notEqual(1, '1');
// AssertionError: 1 != '1'

	AssertionError will be thrown if the values are equal. default error message is assigned when message parameter is undefined. 
	
	assert.notStrictEqual(actual, expected[, message])#

		- actual <any>
		- expected <any>
		- message <any>

	Tests strict inequality between the actual and expected parameters as determined by the SameValue Comparison.
	
	Sample code
	
const assert = require('assert').strict;

assert.notStrictEqual(1, 2);
// OK

assert.notStrictEqual(1, 1);
// AssertionError: 1 notStrictEqual 1

assert.notStrictEqual(1, '1');
// OK

	AssertionError will be thrown when the value are strictly equal. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.ok(value[, message])#

		- value <any>
		- message <any>
	
	In the event that value isn't truthy, an AssertionError is tossed with a message property set equivalent to the estimation of the message parameter. On the off chance that the message parameter is indistinct, a default error message is assigned. In the event that the message parameter is an example of an Error then it will be tossed rather than the AssertionError. On the off chance that no contentions are passed in at all message will be set to the string: "No value contention go to assert.ok".
	
	Sample code

const assert = require('assert').strict;

assert.ok(true);
// OK
assert.ok(1);
// OK

assert.ok();
// throws:
// "AssertionError: No value argument passed to `assert.ok`.

assert.ok(false, 'it\'s false');
// throws "AssertionError: it's false"

// In the repl:
assert.ok(typeof 123 === 'string');
// throws:
// "AssertionError: false == true

// In a file (e.g. test.js):
assert.ok(typeof 123 === 'string');
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(typeof 123 === 'string')

assert.ok(false);
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(false)

assert.ok(0);
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(0)

// Using `assert()` works the same:
assert(0);
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert(0)

	assert.rejects(block[, error][, message])
	
	Added in: v10.0.0
		- block <Function> | <Promise>
		- error <RegExp> | <Function> | <Object> | <Error>
		- message <any>
	
	On the off chance that black is a function and it tosses a error synchronously, assert.rejects() will restore a rejected Promise with that error. On the off chance that the capacity does not restore a guarantee, assert.rejects() will restore a rejected Promise with an ERR_INVALID_RETURN_VALUE mistake. In the two cases the mistake handler is skipped.
	
	If specified, message will be the message provided by the AssertionError if the block fails to reject.
	
	Sample code

(async () => {
  await assert.rejects(
    async () => {
      throw new TypeError('Wrong value');
    },
    {
      name: 'TypeError',
      message: 'Wrong value'
    }
  );
})();
assert.rejects(
  Promise.reject(new Error('Wrong value')),
  Error
).then(() => {
  // ...
});
	
	assert.strictEqual(actual, expected[, message])
		- actual <any>
		- expected <any>
		- message <any>
	
	Tests strict equality between the actual and expected parameters as determined by the SameValue Comparison.
	
	Sample code

const assert = require('assert').strict;

assert.strictEqual(1, 2);
// AssertionError: 1 strictEqual 2

assert.strictEqual(1, 1);
// OK

assert.strictEqual(1, '1');
// AssertionError: 1 strictEqual '1'

	assert.throws(block[, error][, message])
		- block <Function>
		- error <RegExp> | <Function> | <Object> | <Error>
		- message <any>
	
	If specified, error can be a Class, RegExp, a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable message and name properties.
	
	Sample code
	
assert.throws(
  () => {
    throw new Error('Wrong value');
  },
  Error
);

ASYNC HOOKS

The async_hooks module provides an API to register callbacks tracking the lifetime of asynchronous resources created inside a Node.js application. It can be accessed using:
const async_hooks = require('async_hooks');

Terminology

Asynchronous resource represents an object associated with callback and can be called multiple timws, an example would be the 'connection' event in net.createServer(), or just a single time like in fs.open(). AsyncHook represents them as the abstract concept that is a source.

Overview

Following is a simple overview of the public API.

Sample Code

const async_hooks = require('async_hooks');
// Return the ID of the current execution context.const eid = async_hooks.executionAsyncId();
// Return the ID of the handle responsible for triggering the callback of the// current execution scope to call.const tid = async_hooks.triggerAsyncId();
// Create a new AsyncHook instance. All of these callbacks are optional.const asyncHook =
    async_hooks.createHook({ init, before, after, destroy, promiseResolve });
// Allow callbacks of this AsyncHook instance to call. This is not an implicit// action after running the constructor, and must be explicitly run to begin// executing callbacks.
asyncHook.enable();
// Disable listening for new asynchronous events.
asyncHook.disable();
//// The following are the callbacks that can be passed to createHook().//
// init is called during object construction. The resource may not have// completed construction when this callback runs, therefore all fields of the// resource referenced by "asyncId" may not have been populated.function init(asyncId, type, triggerAsyncId, resource) { }
// before is called just before the resource's callback is called. It can be// called 0-N times for handles (e.g. TCPWrap), and will be called exactly 1// time for requests (e.g. FSReqWrap).function before(asyncId) { }
// after is called just after the resource's callback has finished.function after(asyncId) { }
// destroy is called when an AsyncWrap instance is destroyed.function destroy(asyncId) { }
// promiseResolve is called only for promise resources, when the// `resolve` function passed to the `Promise` constructor is invoked// (either directly or through other means of resolving a promise).function promiseResolve(asyncId) { }

async_hooks.createHook(callbacks)

	- callbacks <Object> The Hook Callbacks to register
		- init <Function> The init callback.
		- before <Function> The before callback.
		- after <Function> The after callback.
		- destroy <Function> The destroy callback.
		- Returns: <AsyncHook> Instance used for disabling and enabling hooks

Registers functions to be called for different lifetime events of each async operation.

The callbacks init()/before()/after()/destroy() are called for the respective asynchronous event during a resource's lifetime which are optional to use, specifics of all functions that passes through callbacks is in the Hook Callbacks section.

Error Handling

	The application will print the stack trace and exits when any AsyncHook callbacks throw. All 'uncaughtException' listeners are removed forcing the process to exit. With that, 'exit' callbacks will still be called unless the application is run with --abort-on-uncaught-exception.

	Callbacks that are running at pontentially volatile points in an objects lifetime can be the outcome of error handling behaviour.

Printing in Asynchooks callbacks

	console.log() will cause the AsyncHooks callbacks to be called. With the use of  console.log() or similar asynchronous operations inside an AsyncHooks callback function it results into infinite recursion. The simplest way to fix this when debugging is the utilization of synchronous logging operation such as fs.writeSync(1, msg). It is possible to track of what caused the asynchronous operation using the information provided by AsyncHooks itself.

Sample Code

const fs = require('fs');const util = require('util');
function debug(...args) {
  // use a function like this one when debugging inside an AsyncHooks callback
  fs.writeSync(1, `${util.format(...args)}\n`);}



asyncHook.enable()
	- Returns: <AsyncHook> A reference to asyncHook.

	Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.

	The AsyncHook instance is disabled by default. If the AsyncHook instance should be enabled immediately after creation

Sample Code

const async_hooks = require('async_hooks');
const hook = async_hooks.createHook(callbacks).enable();

asyncHook.disable()
	- Returns: <AsyncHook> A reference to asyncHook.

	Once a hook has been disabled it will not be called again until enabled. For API consistency disable() also returns the AsyncHook instance.

Hook Callbacks

Categorized in four(4) different types:

	-asyncId <number> A unique ID for the async resource.
	- type <string> The type of the async resource.
	- triggerAsyncId <number> The unique ID of the async resource in whose execution context this async resource was created.
	- resource <Object> Reference to the resource representing the async operation, needs to be released during destroy.

	Called when a class is constructed that has the possibility to emit an asynchronous event. This does not mean the instance must call before/after before destroy is called, only that the possibility exists. Can also be observed in opening a resource then closing it before it can be used.

Asynchronous context example

	The following is an example with additional information about the calls to init between the before and after calls.

Sample Code

let indent = 0;
async_hooks.createHook({
  init(asyncId, type, triggerAsyncId) {
    const eid = async_hooks.executionAsyncId();
    const indentStr = ' '.repeat(indent);
    fs.writeSync(
      1,
      `${indentStr}${type}(${asyncId}):` +
      ` trigger: ${triggerAsyncId} execution: ${eid}\n`);
  },
  before(asyncId) {
    const indentStr = ' '.repeat(indent);
    fs.writeSync(1, `${indentStr}before:  ${asyncId}\n`);
    indent += 2;
  },
  after(asyncId) {
    indent -= 2;
    const indentStr = ' '.repeat(indent);
    fs.writeSync(1, `${indentStr}after:   ${asyncId}\n`);
  },
  destroy(asyncId) {
    const indentStr = ' '.repeat(indent);
    fs.writeSync(1, `${indentStr}destroy: ${asyncId}\n`);
  },}).enable();
require('net').createServer(() => {}).listen(8080, () => {
  // Let's wait 10ms before logging the server started.
  setTimeout(() => {
    console.log('>>>', async_hooks.executionAsyncId());
  }, 10);});

Output from only starting the server:

TCPSERVERWRAP(2): trigger: 1 execution: 1TickObject(3): trigger: 2 execution: 1
before:  3
  Timeout(4): trigger: 3 execution: 3
  TIMERWRAP(5): trigger: 3 execution: 3
after:   3
destroy: 3
before:  5
  before:  4
    TTYWRAP(6): trigger: 4 execution: 4
    SIGNALWRAP(7): trigger: 4 execution: 4
    TTYWRAP(8): trigger: 4 execution: 4>>> 4
    TickObject(9): trigger: 4 execution: 4
  after:   4
after:   5
before:  9
after:   9
destroy: 4
destroy: 9
destroy: 5


	As illustrated in the example, executionAsyncId() and execution each specify the value of the current execution context; which is delineated by calls to before and after.

	The TCPSERVERWRAP is not part of this graph, even though it was the reason for console.log() being called  because binding to a port without a hostname is a synchronous operation, but to maintain a completely asynchronous API the user's callback is placed in a process.nextTick().

	The graph only shows when a resource was created, not why, so to track the why use triggerAsyncId.

before(asyncId)
	- asyncId <number>

	A callback is called to notify server when an asynchronous operation is being made. The before callback(called 0 to N times) is called just before said callback is executed. asyncId is the unique identifier assigned to the resource about to execute the callback. Persistent asynchronous resources like a TCP server will typically call the before callback multiple times, while other operations like fs.open() will call it only once.

after(asyncld)
	- asyncId <number>
	
	Called immediately after the callback specified in before is completed.

destroy(asyncld)
	- asyncId <number>

	Called after the resource corresponding to asyncId is destroyed. It is also called asynchronously from the embedder API emitDestroy().

PromiseResolve(asyncld)
	- asyncId <number>

	Called when the resolve function passed to the Promise constructor is invoked (either directly or through other means of resolving a promise). It is not necessarily fulfilled or rejected at this point if the Promise was resolved by assuming the state of another Promise.

Sample Code

new Promise((resolve) => resolve(true)).then((a) => {});


async_hooks.executionAsyncId()
	- Returns: <number> The asyncId of the current execution context. Useful to track when something calls.

Sample Code

const async_hooks = require('async_hooks');

console.log(async_hooks.executionAsyncId());  // 1 - bootstrap
fs.open(path, 'r', (err, fd) => {
  console.log(async_hooks.executionAsyncId());  // 6 - open()});


async_hooks.triggerAsyncId()
	- Returns: <number> The ID of the resource responsible for calling the callback that is currently being executed.

Sample Code

const server = net.createServer((conn) => {
  // The resource that caused (or triggered) this callback to be called
  // was that of the new connection. Thus the return value of triggerAsyncId()
  // is the asyncId of "conn".
  async_hooks.triggerAsyncId();
}).listen(port, () => {
  // Even though all callbacks passed to .listen() are wrapped in a nextTick()
  // the callback itself exists because the call to the server's .listen()
  // was made. So the return value would be the ID of the server.
  async_hooks.triggerAsyncId();});


Promise execution tracking
	Given by V8, promise executions are not tasked asynclds because of the relative expensive nature of the promise introspection API. This explains that  programs using promises or async/await will not get correct execution and trigger ids for promise callback contexts by default.

Sample Code

const ah = require('async_hooks');
Promise.resolve(1729).then(() => {
  console.log(`eid ${ah.executionAsyncId()} tid ${ah.triggerAsyncId()}`);});// produces:// eid 1 tid 0


JavaScript Embedder API
	
	Library developers that handle their own asynchronous resources performing tasks like I/O, connection pooling, or managing callback queues may use the AsyncWrap JavaScript API so that all the appropriate callbacks are called.

Class: AsyncResource
	
	Using AsyncResource, users can easily trigger the lifetime events of their own resources. The init hook will trigger when an AsyncResource is instantiated.

The following is an overview of the AsyncResource API.

Sample Code

const { AsyncResource, executionAsyncId } = require('async_hooks');
// AsyncResource() is meant to be extended. Instantiating a// new AsyncResource() also triggers init. If triggerAsyncId is omitted then// async_hook.executionAsyncId() is used.const asyncResource = new AsyncResource(
  type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false });
// Run a function in the execution context of the resource. This will// * establish the context of the resource// * trigger the AsyncHooks before callbacks// * call the provided function `fn` with the supplied arguments// * trigger the AsyncHooks after callbacks// * restore the original execution context
asyncResource.runInAsyncScope(fn, thisArg, ...args);
// Call AsyncHooks destroy callbacks.
asyncResource.emitDestroy();
// Return the unique ID assigned to the AsyncResource instance.
asyncResource.asyncId();
// Return the trigger ID for the AsyncResource instance.
asyncResource.triggerAsyncId();
// Call AsyncHooks before callbacks.// Deprecated: Use asyncResource.runInAsyncScope instead.
asyncResource.emitBefore();
// Call AsyncHooks after callbacks.// Deprecated: Use asyncResource.runInAsyncScope instead.
asyncResource.emitAfter();


new AsyncResource(type[, options])
	- type <string> The type of async event.
	- options <Object>
		- triggerAsyncId <number> The ID of the execution context that created this async event. 
		Default: executionAsyncId().
		
		- requireManualDestroy <boolean> Disables automatic emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. 
		Default: false.
		
Sample Code

class DBQuery extends AsyncResource {
  constructor(db) {
    super('DBQuery');
    this.db = db;
  }

  getInfo(query, callback) {
    this.db.get(query, (err, data) => {
      this.runInAsyncScope(callback, null, err, data);
    });
  }

  close() {
    this.db = null;
    this.emitDestroy();
  }}


asyncResource.runInAsyncScope(fn[, thisArg, ...args])
	- fn <Function> The function to call in the execution context of this async resource.
	- thisArg <any> The receiver to be used for the function call.
	- ...args <any> Optional arguments to pass to the function.

asyncResource.emitBefore()
	
	Call all before callbacks to notify that a new asynchronous execution context is being entered. If nested calls to emitBefore() are made, the stack of asyncIds will be tracked and properly unwound.

asyncResource.emitAfter()
	
	Call all after callbacks. If nested calls to emitBefore() were made, then make sure the stack is unwound properly. Otherwise an error will be thrown. If the user's callback throws an exception, emitAfter() will automatically be called for all asyncIds on the stack if the error is handled by a domain or 'uncaughtException' handler.

asyncResource.emitDestroy()
	
	Call all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.

asyncResource.asyncId()
	- Returns: <number> The unique asyncId assigned to the resource.

asyncResource.triggerAsyncId()
	- Returns: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.

HTTP
	
	Class:http.Agent
	
	An Agent is responsible for managing connection persistence and reuse for HTTP clients. It maintains a queue of pending requests for a given host and port, reusing a single socket connection for each until the queue is empty, at which time the socket is either destroyed or put into a pool where it is kept to be used again for requests to the same host and port. Whether it is destroyed or pooled depends on the keepAlive
	
	Sockets are removed from an agent when the socket emits either a 'close' event or an 'agentRemove' event. When intending to keep one HTTP request open for a long time without keeping it in the agent, something like the following may be done:
	
	Sample code

http.get(options, (res) => {
  // Do stuff
}).on('socket', (socket) => {
  socket.emit('agentRemove');
});

	An agent may also be used for an individual request. By providing {agent: false} as an option to the http.get() or http.request() functions, a one-time use Agent with default options will be used for the client connection.

	agent:false:
	
	Sample code
	
http.get({
  hostname: 'localhost',
  port: 80,
  path: '/',
  agent: false  // create a new agent just for this one request
}, (res) => {
  // Do stuff with response
});

	new Agent([options])
		- options <object> 
			- keepAlive <boolean> = Keep sockets around even when there are no outstanding requests, so they can be utilized for future requests without reestablishing a TCP connection.
			Default: false
			
			- keepAliveMsecs <number> = When using the keepAlive option, specifies the initial delay for TCP Keep-Alive packets. Ignored when the keepAlive option is false or undefined. 
			Default: 1000.
	
			- maxSockets <number> = Maximum number of sockets to allow per host. 
			Default: Infinity.
			
			- maxFreeSockets <number> = Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. 
			Default: 256.
			
	To configure any of them, a custom http.Agent instance must be created.
			
	Sample code
	
const http = require('http');
const keepAliveAgent = new http.Agent({ keepAlive: true });
options.agent = keepAliveAgent;
http.request(options, onResponseCallback);

	agent.createConnection(options[, callback])
	
		- options <Object> Options containing connection details. Check net.createConnection() for the format of the options
		- callback <Function> Callback function that receives the created socket
		- Returns: <net.Socket>
	
	By default, this function is the same as net.createConnection(). However, custom agents may override this method in case greater flexibility is desired.

	A socket/stream can be supplied in one of two ways: by returning the socket/stream from this function, or by passing the socket/stream to callback.

	callback has a signature of (err, stream).
	
	agent.keepSocketAlive(socket)
		- socket <net.Socket>
	
	Called when socket is detached from a request and could be persisted by the Agent. Default behavior is to:
	
	Sample code
	
socket.setKeepAlive(true, this.keepAliveMsecs);
socket.unref();
return true;

	agent.reuseSocket(socket, request)
		- socket <net.Socket>
		- request <http.ClientRequest>
	
	Called when socket is attached to request after being persisted because of the keep-alive options. Default behavior is to:
	
	Sample code:
	
	socket.ref();
	
	agent.destroy()
	
		Destroy any sockets that are currently in use by the agent.
	
	agent.freeSockets
		- <object>
	
	An object which contains arrays of sockets currently awaiting use by the agent when keepAlive is enabled. Do not modify.
	
	agent.getName(options)
	
	- options <Object> A set of options providing information for name generation
		- host <string> A domain name or IP address of the server to issue the request to
		- port <number> Port of remote server
		- localAddress <string> Local interface to bind for network connections when issuing the request
		- family <integer> Must be 4 or 6 if this doesn't equal undefined.
	- Returns: <string>
	
	For an HTTP agent, this returns host:port:localAddress or host:port:localAddress:family.
	
	agent.maxFreeSockets
		- <number>
	
	By default set to 256. For agents with keepAlive enabled, this sets the maximum number of sockets that will be left open in the free state.
	
	agent.maxSockets
		- <number>

	By default set to Infinity. Determines how many concurrent sockets the agent can have open per origin. Origin is the returned value of agent.getName().
	
	agent.requests
		- <Object>
	
	An object which contains queues of requests that have not yet been assigned to sockets. Do not modify.

	agent.sockets
		- <Object>
	
	An object which contains arrays of sockets currently in use by the agent. Do not modify.
	
CLASS: HTTP.ClientRequest
	This object is made inside and returned from http.request(). It speaks to an in-advance demand whose header has just been queued. The header is as yet changeable utilizing the setHeader(name, value), getHeader(name), removeHeader(name) API. The actual header will be sent alongside the main data chunk or when calling request.end().	
	
	Event: 'abort'

	Emitted when the request has been aborted by the client. This event is only emitted on the first call to abort().
	
	Event: 'connect'#

		- response <http.IncomingMessage>
		- socket <net.Socket>
		- head <Buffer>
	
	Produce a server respond each time to a request with a connect method. if the event is not admitted, the client who receiving have their connection closed.
	
	Sample Code
	
const http = require('http');
const net = require('net');
const url = require('url');

// Create an HTTP tunneling proxy
const proxy = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('okay');
});
proxy.on('connect', (req, cltSocket, head) => {
  // connect to an origin server
  const srvUrl = url.parse(`http://${req.url}`);
  const srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () => {
    cltSocket.write('HTTP/1.1 200 Connection Established\r\n' +
                    'Proxy-agent: Node.js-Proxy\r\n' +
                    '\r\n');
    srvSocket.write(head);
    srvSocket.pipe(cltSocket);
    cltSocket.pipe(srvSocket);
  });
});

// now that proxy is running
proxy.listen(1337, '127.0.0.1', () => {

  // make a request to a tunneling proxy
  const options = {
    port: 1337,
    hostname: '127.0.0.1',
    method: 'CONNECT',
    path: 'www.google.com:80'
  };

  const req = http.request(options);
  req.end();

  req.on('connect', (res, socket, head) => {
    console.log('got connected!');

    // make a request over an HTTP tunnel
    socket.write('GET / HTTP/1.1\r\n' +
                 'Host: www.google.com:80\r\n' +
                 'Connection: close\r\n' +
                 '\r\n');
    socket.on('data', (chunk) => {
      console.log(chunk.toString());
    });
    socket.on('end', () => {
      proxy.close();
    });
  });
});

	Event: 'continue'
	
	Emitted when the server sends a '100 Continue' HTTP response, usually because the request contained 'Expect: 100-continue'. This is an instruction that the client should send the request body.
	
	Event: 'information'
	
	Emitted when the server sends a 1xx response (excluding 101 Upgrade). This event is emitted with a callback containing an object with a status code.
	
	Sample Code

const http = require('http');

const options = {
  hostname: '127.0.0.1',
  port: 8080,
  path: '/length_request'
};

// Make a request
const req = http.request(options);
req.end();

req.on('information', (res) => {
  console.log(`Got information prior to main response: ${res.statusCode}`);
});

	Event: 'response'
		- response <http.IncomingMessage>
	
	Emitted when a response is received to this request. This event is emitted only once.
	
	Event: 'socket'
		- socket <net.Socket>
	
	Emitted after a socket is assigned to this request.

	Event: 'timeout'
	
	Emitted when the underlying socket times out from inactivity. This only notifies that the socket has been idle. The request must be aborted manually.
	
	Event: 'upgrade'
		- response <http.IncomingMessage>
		- socket <net.Socket>
		- head <Buffer>
	
	Emitted each time a server responds to a request with an upgrade. If this event is not being listened for and the response status code is 101 Switching Protocols, clients receiving an upgrade header will have their connections closed.
	
	Sample Code
	
const http = require('http');

// Create an HTTP server
const srv = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('okay');
});
srv.on('upgrade', (req, socket, head) => {
  socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
               'Upgrade: WebSocket\r\n' +
               'Connection: Upgrade\r\n' +
               '\r\n');

  socket.pipe(socket); // echo back
});

// now that server is running
srv.listen(1337, '127.0.0.1', () => {

  // make a request
  const options = {
    port: 1337,
    hostname: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  const req = http.request(options);
  req.end();

  req.on('upgrade', (res, socket, upgradeHead) => {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
  });
});
	
	request.abort()
	
	Marks the request as aborting.

	request.aborted
	
	If a request has been aborted, this value is the time when the request was aborted, in milliseconds since 1 January 1970 00:00:00 UTC.

	request.connection
		- <net.Socket>
	
	request.end([data[, encoding]][, callback])#
		- data <string> | <Buffer>
		- encoding <string>
		- callback <Function>
		- Returns: <this>
	
	Finish all the sending request. If any part of the body are unsent,  it will flush them to the stream. If the request is chunked, this will send the terminating '0\r\n\r\n'.
	
	request.flushHeaders()
	
	For efficiency reasons, Node.js normally buffers the request headers until request.end() is called or the first chunk of request data is written. It then tries to pack the request headers and data into a single TCP packet.
	
	request.getHeader(name)

		- name <string>
		- Returns: <any>
	
	Reads out a header on the request. Note that the name is case insensitive. The type of the return value depends on the arguments provided to request.setHeader().
	
	Sample Code

request.setHeader('content-type', 'text/html');
request.setHeader('Content-Length', Buffer.byteLength(body));
request.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
const contentType = request.getHeader('Content-Type');
// contentType is 'text/html'
const contentLength = request.getHeader('Content-Length');
// contentLength is of type number
const setCookie = request.getHeader('set-cookie');
// setCookie is of type string[]

	request.removeHeader(name)
		- name <string>
		
	Removes a header that's already defined into headers object.

	Sample Code
	
request.removeHeader('Content-Type');

	request.setHeader(name, value)
		- name <string>
		- value <any>
		
	Sets a single header value for headers object. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here to send multiple headers with the same name. Non-string values will be stored without modification. 
	
	Sample Code

request.setHeader('Content-Type', 'application/json');

or

request.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
	
	request.setSocketKeepAlive([enable][, initialDelay])
		- enable <boolean>
		- initialDelay <number>
	
	Once a socket is assigned to this request and is connected socket.setKeepAlive() will be called.
	
	request.setTimeout(timeout[, callback])
		- timeout <number> Milliseconds before a request times out.
		- callback <Function> Optional function to be called when a timeout occurs. Same as binding to the 'timeout' event.
		- Returns: <http.ClientRequest>

	Once a socket is assigned to this request and is connected socket.setTimeout() will be called.
	
	request.socket
		-<net.Socket>
	
	In particular, the socket will not emit 'readable' events because of how the protocol parser attaches to the socket.
	 
	Sample Code
	 
const http = require('http');
const options = {
  host: 'www.google.com',
};
const req = http.get(options);
req.end();
req.once('response', (res) => {
  const ip = req.socket.localAddress;
  const port = req.socket.localPort;
  console.log(`Your IP address is ${ip} and your source port is ${port}.`);
  // consume response object
});
	
	request.write(chunk[, encoding][, callback])
		- chunk <string> | <Buffer>
		- encoding <string>
		- callback <Function>
		- Returns: <boolean>
		
	Sends a chunk of the body. By calling this method many times, a request body can be sent to a server — in that case it is suggested to use the ['Transfer-Encoding', 'chunked'] header line when creating the request. The encoding argument is optional and only applies when chunk is a string. Defaults to 'utf8'.
	
	Class: http.Server

	This class inherits from net.Server and has the following additional events:
	
	Event: 'checkContinue'
		- request <http.IncomingMessage>
		- response <http.ServerResponse>
	
HTTP/2

	The http2 module provides an implementation of the HTTP/2 protocol. It can be accessed using:

Sample Code

const http2 = require('http2');

Core API

	The http2 Core API is much more symmetric between client and server than the http API. For instance, most events, like 'error', 'connect' and 'stream', can be emitted either by client-side code or server-side code.

Server-side example
	The utilization of  http2.createSecureServer() is important in the communication process with browser clients since there are no browser supporting unencrypted HTTP/2.

Sample Code

const http2 = require('http2');const fs = require('fs');
const server = http2.createSecureServer({
  key: fs.readFileSync('localhost-privkey.pem'),
  cert: fs.readFileSync('localhost-cert.pem')});
server.on('error', (err) => console.error(err));

server.on('stream', (stream, headers) => {
  // stream is a Duplex
  stream.respond({
    'content-type': 'text/html',
    ':status': 200
  });
  stream.end('<h1>Hello World</h1>');});

server.listen(8443);

Client-Side example

Sample Code

const http2 = require('http2');const fs = require('fs');const client = http2.connect('https://localhost:8443', {
  ca: fs.readFileSync('localhost-cert.pem')});
client.on('error', (err) => console.error(err));
const req = client.request({ ':path': '/' });

req.on('response', (headers, flags) => {
  for (const name in headers) {
    console.log(`${name}: ${headers[name]}`);
  }});

req.setEncoding('utf8');
let data = '';
req.on('data', (chunk) => { data += chunk; });
req.on('end', () => {
  console.log(`\n${data}`);
  client.close();});
req.end();


Class: Http2Session
	- Extends: <EventEmitter>
	
	Each Http2Session instance will exhibit slightly different behaviors depending on whether it is operating as a server or a client. The http2session.type property can be used to determine the mode in which an Http2Session is operating. On the server side, user code should rarely have occasion to work with the Http2Session object directly, with most actions typically taken through interactions with either the Http2Server or Http2Stream objects.

Http2Session and Sockets

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	