ASSERTION TESTING 

	Class: assert.AssertionError
		A subclass of Error that indicates the failure of an assertion.  All errors thrown by the assert module will be instances of the AssertionError class.

	new assert.AssertionError(options)

	- options <Object>
		- message <string> = error message is going to be set to this value.
	- actual <any> =  actual property on the error instance is going to contain this value.
	- expected <any> = expected property on the error instance is going to contain this value.
	- operator <string> = used to indicate what operation was used for comparison.
	- stackStartFn <function> = If provided, the generated stack trace is going to remove all frames up to the provided function.

All instances contain the built-in Error properties (message and name) and:
	- actual <any> = Set to the actual value in case 
 	Example
		assert.strictEqual()
	- expected <any> = Set to the expected value in case 
	Example
		assert.strictEqual()
	- generatedMessage <boolean> = Indicates if the message was auto-generated (true) or not.
	- code <string> This is always set to the string ERR_ASSERTION to indicate that the error is actually an assertion error.
	- operator <string> Set to the passed in operator value.

Sample Code
	
	const assert = require('assert');

// Generate an AssertionError to compare the error message later:
const { message } = new assert.AssertionError({
  actual: 1,
  expected: 2,
  operator: 'strictEqual'
});

// Verify error output:
try {
  assert.strictEqual(1, 2);
} catch (err) {
  assert(err instanceof assert.AssertionError);
  assert.strictEqual(err.message, message);
  assert.strictEqual(err.name, 'AssertionError [ERR_ASSERTION]');
  assert.strictEqual(err.actual, 1);
  assert.strictEqual(err.expected, 2);
  assert.strictEqual(err.code, 'ERR_ASSERTION');
  assert.strictEqual(err.operator, 'strictEqual');
  assert.strictEqual(err.generatedMessage, true);
}

Strict mode
	- When using the strict mode, any assert function will use the equality used in the strict function mode. So assert.deepEqual() will, for example, work the same as assert.deepStrictEqual().

	- On top of that, error messages which involve objects produce an error diff instead of displaying both objects. That is not the case for the legacy mode.

Sample Code

const assert = require('assert').strict;

Example error diff (the expected, actual, and Lines skipped will be on a single row):

Sample code

const assert = require('assert').strict;

assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]);
AssertionError [ERR_ASSERTION]: Input A expected to deepStrictEqual input B:
+ expected
- actual
... Lines skipped

  [
    [
...
      2,
-     3
+     '3'
    ],
...
    5
  ]
	
Legacy mode
	- The Abstract Equality Comparison will be used for any function without "strict" in its name, such as assert.deepEqual().

	Sample code 
		onst assert = require('assert');
	
	assert(value[, message])#
	Added in: v0.5.9
		- value <any>
		- message <any>
	An alias of assert.ok().
	
	assert.deepEqual(actual, expected[, message])#
	
		- actual <any>
		- expected <any>
		- message <any>
	Strict mode

	An alias of assert.deepStrictEqual().
	
	"Deep" equality means that the enumerable "own" properties of child objects are evaluated also:
	
	Sample code
	
	const assert = require('assert');

	const obj1 = {
		a: {
		b: 1
		}
	};
const obj2 = {
  a: {
    b: 2
  }
};
const obj3 = {
  a: {
    b: 1
  }
};
const obj4 = Object.create(obj1);

assert.deepEqual(obj1, obj1);
// OK, object is equal to itself

assert.deepEqual(obj1, obj2);
// AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } }
// values of b are different

assert.deepEqual(obj1, obj3);
// OK, objects are equal

assert.deepEqual(obj1, obj4);
// AssertionError: { a: { b: 1 } } deepEqual {}
// Prototypes are ignored
	
	- If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.deepStrictEqual(actual, expected[, message])#

		- actual <any>
		- expected <any>
		- message <any>

	Tests for deep equality between the actual and expected parameters. "Deep" equality means that the enumerable "own" properties of child objects are recursively evaluated also by the following rules.
	
	Comparison details
	
	- Primitive values are compared using the SameValue Comparison, used by Object.is().
	- Type tags of objects should be the same.
[[Prototype]] of objects are compared using the Strict Equality Comparison.
	- Only enumerable "own" properties are considered.
Error names and messages are always compared, even if these are not enumerable properties.
	- Enumerable own Symbol properties are compared as well.
	- Object wrappers are compared both as objects and unwrapped values.
	- Object properties are compared unordered.
	- Map keys and Set items are compared unordered.
	- Recursion stops when both sides differ or both sides encounter a circular reference.
	- WeakMap and WeakSet comparison does not rely on their values. See below for further details.
	
	Sample code
	
const assert = require('assert').strict;

assert.deepStrictEqual({ a: 1 }, { a: '1' });
// AssertionError: { a: 1 } deepStrictEqual { a: '1' }
// because 1 !== '1' using SameValue comparison

// The following objects don't have own properties
const date = new Date();
const object = {};
const fakeDate = {};
Object.setPrototypeOf(fakeDate, Date.prototype);

assert.deepStrictEqual(object, fakeDate);
// AssertionError: {} deepStrictEqual Date {}
// Different [[Prototype]]

assert.deepStrictEqual(date, fakeDate);
// AssertionError: 2017-03-11T14:25:31.849Z deepStrictEqual Date {}
// Different type tags

assert.deepStrictEqual(NaN, NaN);
// OK, because of the SameValue comparison

assert.deepStrictEqual(new Number(1), new Number(2));
// Fails because the wrapped number is unwrapped and compared as well.
assert.deepStrictEqual(new String('foo'), Object('foo'));
// OK because the object and the string are identical when unwrapped.

assert.deepStrictEqual(-0, -0);
// OK
assert.deepStrictEqual(0, -0);
// AssertionError: 0 deepStrictEqual -0

const symbol1 = Symbol();
const symbol2 = Symbol();
assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol1]: 1 });
// OK, because it is the same symbol on both objects.
assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol2]: 1 });
// Fails because symbol1 !== symbol2!

const weakMap1 = new WeakMap();
const weakMap2 = new WeakMap([[{}, {}]]);
const weakMap3 = new WeakMap();
weakMap3.unequal = true;

assert.deepStrictEqual(weakMap1, weakMap2);
// OK, because it is impossible to compare the entries
assert.deepStrictEqual(weakMap1, weakMap3);
// Fails because weakMap3 has a property that weakMap1 does not contain!
	
	- If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.doesNotReject(block[, error][, message])#
	
	Added in: v10.0.0
		- block <Function> | <Promise>
		- error <RegExp> | <Function>
		- message <any>

	- Awaits the block promise or, if block is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected.
	
	- If block is a function and it throws an error synchronously, assert.doesNotReject() will return a rejected Promise with that error. If the function does not return a promise, assert.doesNotReject() will return a rejected Promise with an ERR_INVALID_RETURN_VALUE error. In both cases the error handler is skipped.
	
	Besides the async nature to await the completion behaves identically to assert.doesNotThrow().
	
	Sample code
	
(async () => {
  await assert.doesNotReject(
    async () => {
      throw new TypeError('Wrong value');
    },
    SyntaxError
  );
})();
assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
  .then(() => {
    // ...
  });
	
	assert.doesNotThrow(block[, error][, message])#

		- block <Function>
		- error <RegExp> | <Function>
		- message <any>
	
	- Please note: Using assert.doesNotThrow() is actually not useful because there is no benefit by catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible.

	- When assert.doesNotThrow() is called, it will immediately call the block function.

	- If an error is thrown and it is the same type as that specified by the error parameter, then an AssertionError is thrown. If the error is of a different type, or if the error parameter is undefined, the error is propagated back to the caller.
	
	The following, for instance, will throw the TypeError because there is no matching error type in the assertion:
	
	Sample code

assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  SyntaxError
);

	However, the following will result in an AssertionError with the message 'Got unwanted exception (TypeError)..':
	
	Sample code

assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  TypeError
);

	If an AssertionError is thrown and a value is provided for the message parameter, the value of message will be appended to the AssertionError message:
	
	Sample code

assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  /Wrong value/,
  'Whoops'
);
// Throws: AssertionError: Got unwanted exception (TypeError). Whoops

	assert.equal(actual, expected[, message])#

	Added in: v0.1.21
		- actual <any>
		- expected <any>
		- message <any>
	
	Strict mode
		
		An alias of assert.strictEqual().
		
	Legacy mode
	
		Stability: 0 - Deprecated: Use assert.strictEqual() instead.
	
	Tests shallow, coercive equality between the actual and expected parameters using the Abstract Equality Comparison ( == ).
	
	Sample code

const assert = require('assert');

assert.equal(1, 1);
// OK, 1 == 1
assert.equal(1, '1');
// OK, 1 == '1'

assert.equal(1, 2);
// AssertionError: 1 == 2
assert.equal({ a: { b: 1 } }, { a: { b: 1 } });
// AssertionError: { a: { b: 1 } } == { a: { b: 1 } }

AssertionError will be thrown if the values are not equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.fail([message])#
	
	Added in: v0.1.21
		- message <any> Default: 'Failed'
	
	- Throws an AssertionError with the provided error message or a default error message. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	Sample code
	
const assert = require('assert').strict;

assert.fail();
// AssertionError [ERR_ASSERTION]: Failed

assert.fail('boom');
// AssertionError [ERR_ASSERTION]: boom

assert.fail(new TypeError('need array'));
// TypeError: need array

	assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])#

		- actual <any>
		- expected <any>
		- message <any>
		- operator <string> Default: '!='
		- stackStartFunction <Function> Default: assert.fail
	
	- If message is falsy, the error message is set as the values of actual and expected separated by the provided operator. If just the two actual and expected arguments are provided, operator will default to '!='. If message is provided as third argument it will be used as the error message and the other arguments will be stored as properties on the thrown object. If stackStartFunction is provided, all stack frames above that function will be removed from stacktrace (see Error.captureStackTrace). If no arguments are given, the default message Failed will be used.
	
	Sample code
	
const assert = require('assert').strict;

assert.fail('a', 'b');
// AssertionError [ERR_ASSERTION]: 'a' != 'b'

assert.fail(1, 2, undefined, '>');
// AssertionError [ERR_ASSERTION]: 1 > 2

assert.fail(1, 2, 'fail');
// AssertionError [ERR_ASSERTION]: fail

assert.fail(1, 2, 'whoops', '>');
// AssertionError [ERR_ASSERTION]: whoops

assert.fail(1, 2, new TypeError('need array'));
// TypeError: need array

	assert.ifError(value)#

		- value <any>
		
	- Throws value if value is not undefined or null. This is useful when testing the error argument in callbacks.
	
	Sample code
	
const assert = require('assert').strict;

assert.ifError(null);
// OK
assert.ifError(0);
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
assert.ifError('error');
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'
assert.ifError(new Error());
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error
	
	
	assert.notDeepEqual(actual, expected[, message])
	
		- actual <any>
		- expected <any>
		- message <any>

	Strict mode
		An alias of assert.notDeepStrictEqual().
		
	Legacy mode
		Deprecated: Use assert.notDeepStrictEqual() instead.

	- Tests for any deep inequality. Opposite of assert.deepEqual().
	
	Sample code

const assert = require('assert');

const obj1 = {
  a: {
    b: 1
  }
};
const obj2 = {
  a: {
    b: 2
  }
};
const obj3 = {
  a: {
    b: 1
  }
};
const obj4 = Object.create(obj1);

assert.notDeepEqual(obj1, obj1);
// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

assert.notDeepEqual(obj1, obj2);
// OK: obj1 and obj2 are not deeply equal

assert.notDeepEqual(obj1, obj3);
// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

assert.notDeepEqual(obj1, obj4);
// OK: obj1 and obj4 are not deeply equal

	assert.notDeepStrictEqual(actual, expected[, message])#

		- actual <any>
		- expected <any>
		- message <any>

	- Tests for deep strict inequality. Opposite of assert.deepStrictEqual().
	
	Sample code

const assert = require('assert').strict;

assert.notDeepStrictEqual({ a: 1 }, { a: '1' });
// OK

	- If the values are deeply and strictly equal, an AssertionError is thrown. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.notEqual(actual, expected[, message])
	
	Added in: v0.1.21
		- actual <any>
		- expected <any>
		- message <any>
	
	Strict mode
		An alias of assert.notStrictEqual().

	Legacy mode
		Use assert.notStrictEqual() instead.
		
	Tests shallow, coercive inequality with the Abstract Equality Comparison ( != ).
	
	Sample code
	
const assert = require('assert');

assert.notEqual(1, 2);
// OK

assert.notEqual(1, 1);
// AssertionError: 1 != 1

assert.notEqual(1, '1');
// AssertionError: 1 != '1'

	AssertionError will be thrown if the values are equal. default error message is assigned when message parameter is undefined. 
	
	assert.notStrictEqual(actual, expected[, message])#

		- actual <any>
		- expected <any>
		- message <any>

	Tests strict inequality between the actual and expected parameters as determined by the SameValue Comparison.
	
	Sample code
	
const assert = require('assert').strict;

assert.notStrictEqual(1, 2);
// OK

assert.notStrictEqual(1, 1);
// AssertionError: 1 notStrictEqual 1

assert.notStrictEqual(1, '1');
// OK

	AssertionError will be thrown when the value are strictly equal. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError.
	
	assert.ok(value[, message])#

		- value <any>
		- message <any>
	
	In the event that value isn't truthy, an AssertionError is tossed with a message property set equivalent to the estimation of the message parameter. On the off chance that the message parameter is indistinct, a default error message is assigned. In the event that the message parameter is an example of an Error then it will be tossed rather than the AssertionError. On the off chance that no contentions are passed in at all message will be set to the string: "No value contention go to assert.ok".
	
	Sample code

const assert = require('assert').strict;

assert.ok(true);
// OK
assert.ok(1);
// OK

assert.ok();
// throws:
// "AssertionError: No value argument passed to `assert.ok`.

assert.ok(false, 'it\'s false');
// throws "AssertionError: it's false"

// In the repl:
assert.ok(typeof 123 === 'string');
// throws:
// "AssertionError: false == true

// In a file (e.g. test.js):
assert.ok(typeof 123 === 'string');
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(typeof 123 === 'string')

assert.ok(false);
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(false)

assert.ok(0);
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(0)

// Using `assert()` works the same:
assert(0);
// throws:
// "AssertionError: The expression evaluated to a falsy value:
//
//   assert(0)

	assert.rejects(block[, error][, message])
	
	Added in: v10.0.0
		- block <Function> | <Promise>
		- error <RegExp> | <Function> | <Object> | <Error>
		- message <any>
	
	On the off chance that black is a function and it tosses a error synchronously, assert.rejects() will restore a rejected Promise with that error. On the off chance that the capacity does not restore a guarantee, assert.rejects() will restore a rejected Promise with an ERR_INVALID_RETURN_VALUE mistake. In the two cases the mistake handler is skipped.
	
	If specified, message will be the message provided by the AssertionError if the block fails to reject.
	
	Sample code

(async () => {
  await assert.rejects(
    async () => {
      throw new TypeError('Wrong value');
    },
    {
      name: 'TypeError',
      message: 'Wrong value'
    }
  );
})();
assert.rejects(
  Promise.reject(new Error('Wrong value')),
  Error
).then(() => {
  // ...
});
	
	assert.strictEqual(actual, expected[, message])
		- actual <any>
		- expected <any>
		- message <any>
	
	Tests strict equality between the actual and expected parameters as determined by the SameValue Comparison.
	
	Sample code

const assert = require('assert').strict;

assert.strictEqual(1, 2);
// AssertionError: 1 strictEqual 2

assert.strictEqual(1, 1);
// OK

assert.strictEqual(1, '1');
// AssertionError: 1 strictEqual '1'

	assert.throws(block[, error][, message])
		- block <Function>
		- error <RegExp> | <Function> | <Object> | <Error>
		- message <any>
	
	If specified, error can be a Class, RegExp, a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable message and name properties.
	
	Sample code
	
assert.throws(
  () => {
    throw new Error('Wrong value');
  },
  Error
);

ASYNC HOOKS

The async_hooks module provides an API to register callbacks tracking the lifetime of asynchronous resources created inside a Node.js application. It can be accessed using:
const async_hooks = require('async_hooks');

Terminology

Asynchronous resource represents an object associated with callback and can be called multiple timws, an example would be the 'connection' event in net.createServer(), or just a single time like in fs.open(). AsyncHook represents them as the abstract concept that is a source.

Overview

Following is a simple overview of the public API.

Sample Code

const async_hooks = require('async_hooks');
// Return the ID of the current execution context.const eid = async_hooks.executionAsyncId();
// Return the ID of the handle responsible for triggering the callback of the// current execution scope to call.const tid = async_hooks.triggerAsyncId();
// Create a new AsyncHook instance. All of these callbacks are optional.const asyncHook =
    async_hooks.createHook({ init, before, after, destroy, promiseResolve });
// Allow callbacks of this AsyncHook instance to call. This is not an implicit// action after running the constructor, and must be explicitly run to begin// executing callbacks.
asyncHook.enable();
// Disable listening for new asynchronous events.
asyncHook.disable();
//// The following are the callbacks that can be passed to createHook().//
// init is called during object construction. The resource may not have// completed construction when this callback runs, therefore all fields of the// resource referenced by "asyncId" may not have been populated.function init(asyncId, type, triggerAsyncId, resource) { }
// before is called just before the resource's callback is called. It can be// called 0-N times for handles (e.g. TCPWrap), and will be called exactly 1// time for requests (e.g. FSReqWrap).function before(asyncId) { }
// after is called just after the resource's callback has finished.function after(asyncId) { }
// destroy is called when an AsyncWrap instance is destroyed.function destroy(asyncId) { }
// promiseResolve is called only for promise resources, when the// `resolve` function passed to the `Promise` constructor is invoked// (either directly or through other means of resolving a promise).function promiseResolve(asyncId) { }

async_hooks.createHook(callbacks)

	- callbacks <Object> The Hook Callbacks to register
		- init <Function> The init callback.
		- before <Function> The before callback.
		- after <Function> The after callback.
		- destroy <Function> The destroy callback.
		- Returns: <AsyncHook> Instance used for disabling and enabling hooks

Registers functions to be called for different lifetime events of each async operation.

The callbacks init()/before()/after()/destroy() are called for the respective asynchronous event during a resource's lifetime which are optional to use, specifics of all functions that passes through callbacks is in the Hook Callbacks section.

Error Handling

	The application will print the stack trace and exits when any AsyncHook callbacks throw. All 'uncaughtException' listeners are removed forcing the process to exit. With that, 'exit' callbacks will still be called unless the application is run with --abort-on-uncaught-exception.

	Callbacks that are running at pontentially volatile points in an objects lifetime can be the outcome of error handling behaviour.

Printing in Asynchooks callbacks

	console.log() will cause the AsyncHooks callbacks to be called. With the use of  console.log() or similar asynchronous operations inside an AsyncHooks callback function it results into infinite recursion. The simplest way to fix this when debugging is the utilization of synchronous logging operation such as fs.writeSync(1, msg). It is possible to track of what caused the asynchronous operation using the information provided by AsyncHooks itself.

Sample Code

const fs = require('fs');const util = require('util');
function debug(...args) {
  // use a function like this one when debugging inside an AsyncHooks callback
  fs.writeSync(1, `${util.format(...args)}\n`);}



asyncHook.enable()
	- Returns: <AsyncHook> A reference to asyncHook.

	Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.

	The AsyncHook instance is disabled by default. If the AsyncHook instance should be enabled immediately after creation

Sample Code

const async_hooks = require('async_hooks');
const hook = async_hooks.createHook(callbacks).enable();

asyncHook.disable()
	- Returns: <AsyncHook> A reference to asyncHook.

	Once a hook has been disabled it will not be called again until enabled. For API consistency disable() also returns the AsyncHook instance.

Hook Callbacks

Categorized in four(4) different types:

	-asyncId <number> A unique ID for the async resource.
	- type <string> The type of the async resource.
	- triggerAsyncId <number> The unique ID of the async resource in whose execution context this async resource was created.
	- resource <Object> Reference to the resource representing the async operation, needs to be released during destroy.

	Called when a class is constructed that has the possibility to emit an asynchronous event. This does not mean the instance must call before/after before destroy is called, only that the possibility exists. Can also be observed in opening a resource then closing it before it can be used.

Asynchronous context example

	The following is an example with additional information about the calls to init between the before and after calls.

Sample Code

let indent = 0;
async_hooks.createHook({
  init(asyncId, type, triggerAsyncId) {
    const eid = async_hooks.executionAsyncId();
    const indentStr = ' '.repeat(indent);
    fs.writeSync(
      1,
      `${indentStr}${type}(${asyncId}):` +
      ` trigger: ${triggerAsyncId} execution: ${eid}\n`);
  },
  before(asyncId) {
    const indentStr = ' '.repeat(indent);
    fs.writeSync(1, `${indentStr}before:  ${asyncId}\n`);
    indent += 2;
  },
  after(asyncId) {
    indent -= 2;
    const indentStr = ' '.repeat(indent);
    fs.writeSync(1, `${indentStr}after:   ${asyncId}\n`);
  },
  destroy(asyncId) {
    const indentStr = ' '.repeat(indent);
    fs.writeSync(1, `${indentStr}destroy: ${asyncId}\n`);
  },}).enable();
require('net').createServer(() => {}).listen(8080, () => {
  // Let's wait 10ms before logging the server started.
  setTimeout(() => {
    console.log('>>>', async_hooks.executionAsyncId());
  }, 10);});

Output from only starting the server:

TCPSERVERWRAP(2): trigger: 1 execution: 1TickObject(3): trigger: 2 execution: 1
before:  3
  Timeout(4): trigger: 3 execution: 3
  TIMERWRAP(5): trigger: 3 execution: 3
after:   3
destroy: 3
before:  5
  before:  4
    TTYWRAP(6): trigger: 4 execution: 4
    SIGNALWRAP(7): trigger: 4 execution: 4
    TTYWRAP(8): trigger: 4 execution: 4>>> 4
    TickObject(9): trigger: 4 execution: 4
  after:   4
after:   5
before:  9
after:   9
destroy: 4
destroy: 9
destroy: 5


	As illustrated in the example, executionAsyncId() and execution each specify the value of the current execution context; which is delineated by calls to before and after.

	The TCPSERVERWRAP is not part of this graph, even though it was the reason for console.log() being called  because binding to a port without a hostname is a synchronous operation, but to maintain a completely asynchronous API the user's callback is placed in a process.nextTick().

	The graph only shows when a resource was created, not why, so to track the why use triggerAsyncId.

before(asyncId)
	- asyncId <number>

	A callback is called to notify server when an asynchronous operation is being made. The before callback(called 0 to N times) is called just before said callback is executed. asyncId is the unique identifier assigned to the resource about to execute the callback. Persistent asynchronous resources like a TCP server will typically call the before callback multiple times, while other operations like fs.open() will call it only once.

after(asyncld)
	- asyncId <number>
	
	Called immediately after the callback specified in before is completed.

destroy(asyncld)
	- asyncId <number>

	Called after the resource corresponding to asyncId is destroyed. It is also called asynchronously from the embedder API emitDestroy().

PromiseResolve(asyncld)
	- asyncId <number>

	Called when the resolve function passed to the Promise constructor is invoked (either directly or through other means of resolving a promise). It is not necessarily fulfilled or rejected at this point if the Promise was resolved by assuming the state of another Promise.

Sample Code

new Promise((resolve) => resolve(true)).then((a) => {});


async_hooks.executionAsyncId()
	- Returns: <number> The asyncId of the current execution context. Useful to track when something calls.

Sample Code

const async_hooks = require('async_hooks');

console.log(async_hooks.executionAsyncId());  // 1 - bootstrap
fs.open(path, 'r', (err, fd) => {
  console.log(async_hooks.executionAsyncId());  // 6 - open()});


async_hooks.triggerAsyncId()
	- Returns: <number> The ID of the resource responsible for calling the callback that is currently being executed.

Sample Code

const server = net.createServer((conn) => {
  // The resource that caused (or triggered) this callback to be called
  // was that of the new connection. Thus the return value of triggerAsyncId()
  // is the asyncId of "conn".
  async_hooks.triggerAsyncId();
}).listen(port, () => {
  // Even though all callbacks passed to .listen() are wrapped in a nextTick()
  // the callback itself exists because the call to the server's .listen()
  // was made. So the return value would be the ID of the server.
  async_hooks.triggerAsyncId();});


Promise execution tracking
	Given by V8, promise executions are not tasked asynclds because of the relative expensive nature of the promise introspection API. This explains that  programs using promises or async/await will not get correct execution and trigger ids for promise callback contexts by default.

Sample Code

const ah = require('async_hooks');
Promise.resolve(1729).then(() => {
  console.log(`eid ${ah.executionAsyncId()} tid ${ah.triggerAsyncId()}`);});// produces:// eid 1 tid 0


JavaScript Embedder API
	
	Library developers that handle their own asynchronous resources performing tasks like I/O, connection pooling, or managing callback queues may use the AsyncWrap JavaScript API so that all the appropriate callbacks are called.

Class: AsyncResource
	
	Using AsyncResource, users can easily trigger the lifetime events of their own resources. The init hook will trigger when an AsyncResource is instantiated.

The following is an overview of the AsyncResource API.

Sample Code

const { AsyncResource, executionAsyncId } = require('async_hooks');
// AsyncResource() is meant to be extended. Instantiating a// new AsyncResource() also triggers init. If triggerAsyncId is omitted then// async_hook.executionAsyncId() is used.const asyncResource = new AsyncResource(
  type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false });
// Run a function in the execution context of the resource. This will// * establish the context of the resource// * trigger the AsyncHooks before callbacks// * call the provided function `fn` with the supplied arguments// * trigger the AsyncHooks after callbacks// * restore the original execution context
asyncResource.runInAsyncScope(fn, thisArg, ...args);
// Call AsyncHooks destroy callbacks.
asyncResource.emitDestroy();
// Return the unique ID assigned to the AsyncResource instance.
asyncResource.asyncId();
// Return the trigger ID for the AsyncResource instance.
asyncResource.triggerAsyncId();
// Call AsyncHooks before callbacks.// Deprecated: Use asyncResource.runInAsyncScope instead.
asyncResource.emitBefore();
// Call AsyncHooks after callbacks.// Deprecated: Use asyncResource.runInAsyncScope instead.
asyncResource.emitAfter();


new AsyncResource(type[, options])
	- type <string> The type of async event.
	- options <Object>
		- triggerAsyncId <number> The ID of the execution context that created this async event. 
		Default: executionAsyncId().
		
		- requireManualDestroy <boolean> Disables automatic emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. 
		Default: false.
		
Sample Code

class DBQuery extends AsyncResource {
  constructor(db) {
    super('DBQuery');
    this.db = db;
  }

  getInfo(query, callback) {
    this.db.get(query, (err, data) => {
      this.runInAsyncScope(callback, null, err, data);
    });
  }

  close() {
    this.db = null;
    this.emitDestroy();
  }}


asyncResource.runInAsyncScope(fn[, thisArg, ...args])
	- fn <Function> The function to call in the execution context of this async resource.
	- thisArg <any> The receiver to be used for the function call.
	- ...args <any> Optional arguments to pass to the function.

asyncResource.emitBefore()
	
	Call all before callbacks to notify that a new asynchronous execution context is being entered. If nested calls to emitBefore() are made, the stack of asyncIds will be tracked and properly unwound.

asyncResource.emitAfter()
	
	Call all after callbacks. If nested calls to emitBefore() were made, then make sure the stack is unwound properly. Otherwise an error will be thrown. If the user's callback throws an exception, emitAfter() will automatically be called for all asyncIds on the stack if the error is handled by a domain or 'uncaughtException' handler.

asyncResource.emitDestroy()
	
	Call all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.

asyncResource.asyncId()
	- Returns: <number> The unique asyncId assigned to the resource.

asyncResource.triggerAsyncId()
	- Returns: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.

HTTP
	
	Class:http.Agent
	
	An Agent is responsible for managing connection persistence and reuse for HTTP clients. It maintains a queue of pending requests for a given host and port, reusing a single socket connection for each until the queue is empty, at which time the socket is either destroyed or put into a pool where it is kept to be used again for requests to the same host and port. Whether it is destroyed or pooled depends on the keepAlive
	
	Sockets are removed from an agent when the socket emits either a 'close' event or an 'agentRemove' event. When intending to keep one HTTP request open for a long time without keeping it in the agent, something like the following may be done:
	
	Sample code

http.get(options, (res) => {
  // Do stuff
}).on('socket', (socket) => {
  socket.emit('agentRemove');
});

	An agent may also be used for an individual request. By providing {agent: false} as an option to the http.get() or http.request() functions, a one-time use Agent with default options will be used for the client connection.

	agent:false:
	
	Sample code
	
http.get({
  hostname: 'localhost',
  port: 80,
  path: '/',
  agent: false  // create a new agent just for this one request
}, (res) => {
  // Do stuff with response
});

	new Agent([options])
		- options <object> 
			- keepAlive <boolean> = Keep sockets around even when there are no outstanding requests, so they can be utilized for future requests without reestablishing a TCP connection.
			Default: false
			
			- keepAliveMsecs <number> = When using the keepAlive option, specifies the initial delay for TCP Keep-Alive packets. Ignored when the keepAlive option is false or undefined. 
			Default: 1000.
	
			- maxSockets <number> = Maximum number of sockets to allow per host. 
			Default: Infinity.
			
			- maxFreeSockets <number> = Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. 
			Default: 256.
			
	To configure any of them, a custom http.Agent instance must be created.
			
	Sample code
	
const http = require('http');
const keepAliveAgent = new http.Agent({ keepAlive: true });
options.agent = keepAliveAgent;
http.request(options, onResponseCallback);

	agent.createConnection(options[, callback])
	
		- options <Object> Options containing connection details. Check net.createConnection() for the format of the options
		- callback <Function> Callback function that receives the created socket
		- Returns: <net.Socket>
	
	By default, this function is the same as net.createConnection(). However, custom agents may override this method in case greater flexibility is desired.

	A socket/stream can be supplied in one of two ways: by returning the socket/stream from this function, or by passing the socket/stream to callback.

	callback has a signature of (err, stream).
	
	agent.keepSocketAlive(socket)
		- socket <net.Socket>
	
	Called when socket is detached from a request and could be persisted by the Agent. Default behavior is to:
	
	Sample code
	
socket.setKeepAlive(true, this.keepAliveMsecs);
socket.unref();
return true;

	agent.reuseSocket(socket, request)
		- socket <net.Socket>
		- request <http.ClientRequest>
	
	Called when socket is attached to request after being persisted because of the keep-alive options. Default behavior is to:
	
	Sample code:
	
	socket.ref();
	
	agent.destroy()
	
		Destroy any sockets that are currently in use by the agent.
	
	agent.freeSockets
		- <object>
	
	An object which contains arrays of sockets currently awaiting use by the agent when keepAlive is enabled. Do not modify.
	
	agent.getName(options)
	
	- options <Object> A set of options providing information for name generation
		- host <string> A domain name or IP address of the server to issue the request to
		- port <number> Port of remote server
		- localAddress <string> Local interface to bind for network connections when issuing the request
		- family <integer> Must be 4 or 6 if this doesn't equal undefined.
	- Returns: <string>
	
	For an HTTP agent, this returns host:port:localAddress or host:port:localAddress:family.
	
	agent.maxFreeSockets
		- <number>
	
	By default set to 256. For agents with keepAlive enabled, this sets the maximum number of sockets that will be left open in the free state.
	
	agent.maxSockets
		- <number>

	By default set to Infinity. Determines how many concurrent sockets the agent can have open per origin. Origin is the returned value of agent.getName().
	
	agent.requests
		- <Object>
	
	An object which contains queues of requests that have not yet been assigned to sockets. Do not modify.

	agent.sockets
		- <Object>
	
	An object which contains arrays of sockets currently in use by the agent. Do not modify.
	
CLASS: HTTP.ClientRequest
	This object is made inside and returned from http.request(). It speaks to an in-advance demand whose header has just been queued. The header is as yet changeable utilizing the setHeader(name, value), getHeader(name), removeHeader(name) API. The actual header will be sent alongside the main data chunk or when calling request.end().	
	
	Event: 'abort'

	Emitted when the request has been aborted by the client. This event is only emitted on the first call to abort().
	
	Event: 'connect'#

		- response <http.IncomingMessage>
		- socket <net.Socket>
		- head <Buffer>
	
	Produce a server respond each time to a request with a connect method. if the event is not admitted, the client who receiving have their connection closed.
	
	Sample Code
	
const http = require('http');
const net = require('net');
const url = require('url');

// Create an HTTP tunneling proxy
const proxy = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('okay');
});
proxy.on('connect', (req, cltSocket, head) => {
  // connect to an origin server
  const srvUrl = url.parse(`http://${req.url}`);
  const srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () => {
    cltSocket.write('HTTP/1.1 200 Connection Established\r\n' +
                    'Proxy-agent: Node.js-Proxy\r\n' +
                    '\r\n');
    srvSocket.write(head);
    srvSocket.pipe(cltSocket);
    cltSocket.pipe(srvSocket);
  });
});

// now that proxy is running
proxy.listen(1337, '127.0.0.1', () => {

  // make a request to a tunneling proxy
  const options = {
    port: 1337,
    hostname: '127.0.0.1',
    method: 'CONNECT',
    path: 'www.google.com:80'
  };

  const req = http.request(options);
  req.end();

  req.on('connect', (res, socket, head) => {
    console.log('got connected!');

    // make a request over an HTTP tunnel
    socket.write('GET / HTTP/1.1\r\n' +
                 'Host: www.google.com:80\r\n' +
                 'Connection: close\r\n' +
                 '\r\n');
    socket.on('data', (chunk) => {
      console.log(chunk.toString());
    });
    socket.on('end', () => {
      proxy.close();
    });
  });
});

	Event: 'continue'
	
	Emitted when the server sends a '100 Continue' HTTP response, usually because the request contained 'Expect: 100-continue'. This is an instruction that the client should send the request body.
	
	Event: 'information'
	
	Emitted when the server sends a 1xx response (excluding 101 Upgrade). This event is emitted with a callback containing an object with a status code.
	
	Sample Code

const http = require('http');

const options = {
  hostname: '127.0.0.1',
  port: 8080,
  path: '/length_request'
};

// Make a request
const req = http.request(options);
req.end();

req.on('information', (res) => {
  console.log(`Got information prior to main response: ${res.statusCode}`);
});

	Event: 'response'
		- response <http.IncomingMessage>
	
	Emitted when a response is received to this request. This event is emitted only once.
	
	Event: 'socket'
		- socket <net.Socket>
	
	Emitted after a socket is assigned to this request.

	Event: 'timeout'
	
	Emitted when the underlying socket times out from inactivity. This only notifies that the socket has been idle. The request must be aborted manually.
	
	Event: 'upgrade'
		- response <http.IncomingMessage>
		- socket <net.Socket>
		- head <Buffer>
	
	Emitted each time a server responds to a request with an upgrade. If this event is not being listened for and the response status code is 101 Switching Protocols, clients receiving an upgrade header will have their connections closed.
	
	Sample Code
	
const http = require('http');

// Create an HTTP server
const srv = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('okay');
});
srv.on('upgrade', (req, socket, head) => {
  socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
               'Upgrade: WebSocket\r\n' +
               'Connection: Upgrade\r\n' +
               '\r\n');

  socket.pipe(socket); // echo back
});

// now that server is running
srv.listen(1337, '127.0.0.1', () => {

  // make a request
  const options = {
    port: 1337,
    hostname: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  const req = http.request(options);
  req.end();

  req.on('upgrade', (res, socket, upgradeHead) => {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
  });
});
	
	request.abort()
	
	Marks the request as aborting.

	request.aborted
	
	If a request has been aborted, this value is the time when the request was aborted, in milliseconds since 1 January 1970 00:00:00 UTC.

	request.connection
		- <net.Socket>
	
	request.end([data[, encoding]][, callback])#
		- data <string> | <Buffer>
		- encoding <string>
		- callback <Function>
		- Returns: <this>
	
	Finish all the sending request. If any part of the body are unsent,  it will flush them to the stream. If the request is chunked, this will send the terminating '0\r\n\r\n'.
	
	request.flushHeaders()
	
	For efficiency reasons, Node.js normally buffers the request headers until request.end() is called or the first chunk of request data is written. It then tries to pack the request headers and data into a single TCP packet.
	
	request.getHeader(name)

		- name <string>
		- Returns: <any>
	
	Reads out a header on the request. Note that the name is case insensitive. The type of the return value depends on the arguments provided to request.setHeader().
	
	Sample Code

request.setHeader('content-type', 'text/html');
request.setHeader('Content-Length', Buffer.byteLength(body));
request.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
const contentType = request.getHeader('Content-Type');
// contentType is 'text/html'
const contentLength = request.getHeader('Content-Length');
// contentLength is of type number
const setCookie = request.getHeader('set-cookie');
// setCookie is of type string[]

	request.removeHeader(name)
		- name <string>
		
	Removes a header that's already defined into headers object.

	Sample Code
	
request.removeHeader('Content-Type');

	request.setHeader(name, value)
		- name <string>
		- value <any>
		
	Sets a single header value for headers object. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here to send multiple headers with the same name. Non-string values will be stored without modification. 
	
	Sample Code

request.setHeader('Content-Type', 'application/json');

or

request.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
	
	request.setSocketKeepAlive([enable][, initialDelay])
		- enable <boolean>
		- initialDelay <number>
	
	Once a socket is assigned to this request and is connected socket.setKeepAlive() will be called.
	
	request.setTimeout(timeout[, callback])
		- timeout <number> Milliseconds before a request times out.
		- callback <Function> Optional function to be called when a timeout occurs. Same as binding to the 'timeout' event.
		- Returns: <http.ClientRequest>

	Once a socket is assigned to this request and is connected socket.setTimeout() will be called.
	
	request.socket
		-<net.Socket>
	
	In particular, the socket will not emit 'readable' events because of how the protocol parser attaches to the socket.
	 
	Sample Code
	 
const http = require('http');
const options = {
  host: 'www.google.com',
};
const req = http.get(options);
req.end();
req.once('response', (res) => {
  const ip = req.socket.localAddress;
  const port = req.socket.localPort;
  console.log(`Your IP address is ${ip} and your source port is ${port}.`);
  // consume response object
});
	
	request.write(chunk[, encoding][, callback])
		- chunk <string> | <Buffer>
		- encoding <string>
		- callback <Function>
		- Returns: <boolean>
		
	Sends a chunk of the body. By calling this method many times, a request body can be sent to a server — in that case it is suggested to use the ['Transfer-Encoding', 'chunked'] header line when creating the request. The encoding argument is optional and only applies when chunk is a string. Defaults to 'utf8'.
	
	Class: http.Server

	This class inherits from net.Server and has the following additional events:
	
	Event: 'checkContinue'
		- request <http.IncomingMessage>
		- response <http.ServerResponse>

	emitted each time a demand with a HTTP Expect: 100-continue is gotten. In the event that this occasion isn't tuned in for, the server will consequently react with a 100 Continue as proper.

* Note that when this event is emitted and handled, the 'request' event will not be emitted.

	Event: 'clientExpectation'
		- request <http.IncomingMessage>
		- response <http.SeverResponse>
	
	emitted each time a deand with an HTTP Expect header is gotten, where the value is not 100-continue. In the event that this occasion isn't tuned in for, the server will consequently react with a 417 Expectation Failed as proper.

* Note that when this event is emitted and handled, the 'request' event will not be emitted.
	
	Event: 'clientError'

	
	
HTTP/2

	The http2 module provides an implementation of the HTTP/2 protocol. It can be accessed using:

Sample Code

const http2 = require('http2');

Core API

	The http2 Core API is much more symmetric between client and server than the http API. For instance, most events, like 'error', 'connect' and 'stream', can be emitted either by client-side code or server-side code.

Server-side example
	The utilization of  http2.createSecureServer() is important in the communication process with browser clients since there are no browser supporting unencrypted HTTP/2.

Sample Code

const http2 = require('http2');const fs = require('fs');
const server = http2.createSecureServer({
  key: fs.readFileSync('localhost-privkey.pem'),
  cert: fs.readFileSync('localhost-cert.pem')});
server.on('error', (err) => console.error(err));

server.on('stream', (stream, headers) => {
  // stream is a Duplex
  stream.respond({
    'content-type': 'text/html',
    ':status': 200
  });
  stream.end('<h1>Hello World</h1>');});

server.listen(8443);

Client-Side example

Sample Code

const http2 = require('http2');const fs = require('fs');const client = http2.connect('https://localhost:8443', {
  ca: fs.readFileSync('localhost-cert.pem')});
client.on('error', (err) => console.error(err));
const req = client.request({ ':path': '/' });

req.on('response', (headers, flags) => {
  for (const name in headers) {
    console.log(`${name}: ${headers[name]}`);
  }});

req.setEncoding('utf8');
let data = '';
req.on('data', (chunk) => { data += chunk; });
req.on('end', () => {
  console.log(`\n${data}`);
  client.close();});
req.end();


Class: Http2Session
	- Extends: <EventEmitter>
	
	Each Http2Session instance will exhibit slightly different behaviors depending on whether it is operating as a server or a client. The http2session.type property can be used to determine the mode in which an Http2Session is operating. On the server side, user code should rarely have occasion to work with the Http2Session object directly, with most actions typically taken through interactions with either the Http2Server or Http2Stream objects.

Http2Session and Sockets
Http2session is related with either net.Sicket or tls.TLSSocket when created, that is why whenever one gets destroyed it will both affect them.

It is not advisable to read data from or write data for user code to a Socket instance bound to Http2Session as per imposed in HTTP/2 protocol because this will lead HTTP/2’s session and socket become unusable.

Event: ‘close’
Once the Http2session has been destroyed, ‘close’ event is released and its listener expects no argument at all.

Event: ‘connect’
	- session <Http2Session>
	- socket <net.Socket>

When Http2Session has been connected successfully to the remote peer, ‘connect’ event is released that makes communication begin. User code does not listen to this event directly.

Event: ‘error’
	- error <Error>
When an error occurs in the process of Http2Session, ‘error’ event is being released.

Event: ‘frameError’

In the process of trying to send a frame on the session and an error suddenly occurred, ‘frameError’ event is released. 

Handler function receives three arguments when invoked:
	- An integer identifying the frame type.
	- An integer identifying the error code.
	- An integer identifying the stream (or 0 if the frame is not associated with a stream).

The stream will be closed and destroyed immediately following ‘frameError’ event, if the event is not associated with a stream, Http2Session will be shut down right away following the ‘frameError’ event.

Event:’goaway’
The 'goaway' event is emitted when a GOAWAY frame is received. When invoked, the handler function will receive three arguments:

	- errorCode <number> The HTTP/2 error code specified in the GOAWAY frame.
	- lastStreamID <number> The ID of the last stream the remote peer successfully processed (or 0 if no ID is specified).
	- opaqueData <Buffer> If additional opaque data was included in the GOAWAY frame, a Buffer instance will be passed containing that data.

The Http2Session instance will be shut down automatically when the 'goaway' event is emitted.

Event: ‘localSettings’
When a recognized Settings frame has been received, this is the time when ‘localSettings’ event is released giving the handler function a copy of the local settings.

Sample Code

session.settings({ enablePush: false });

session.on('localSettings', (settings) => {
  /* Use the new settings */});


Event: ‘remoteSettings’
	If the connected peer received a new SETTINGS, ‘remoteSettings’ will now be released, then handler function will receive a copy of the remote settings when invoked.

Sample Code

session.on('remoteSettings', (settings) => {
  /* Use the new settings */});


Event: ‘stream’
	The 'stream' event is emitted when a new Http2Stream is created. When invoked, the handler function will receive a reference to the Http2Stream object, a HTTP/2 Headers Object, and numeric flags associated with the creation of the stream. User code does not usually listen to this event but registers a handler for the ‘stream’ event emitted by the net.Server or tls.Server.

Sample Code

const http2 = require('http2');
session.on('stream', (stream, headers, flags) => {
  const method = headers[':method'];
  const path = headers[':path'];
  // ...
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });
  stream.write('hello ');
  stream.end('world');});

Event: ‘timeout’
	The ‘timeout’ event is released when there is no activity on Http2Session milliseconds after being configured when http2session.setTimeout() method is utilized.

Sample Code

session.setTimeout(2000);
session.on('timeout', () => { /* .. */ });


http2session.alpnProtocol
	If the Http2Session is not yet connected to a socket the value will be undefined, h2c if the Http2Session is not connected to a TLSSocket, or will return the value of the connected TLSSocket's own alpnProtocol property.



http2session.close([callback])
	Prevents new Http2Stream to be created, giving a way for existing streams to be fully done. http2session.destroy() might be called if there are no open Http2Stream instances once closed.

	The callback function is registered as a handler for the ‘close’ event when identified.

http2session.closed
	Will be true if this Http2Session instance has been closed, otherwise false.

http2session.connecting
	Will be true if this Http2Session instance is still connecting, will be set to false before emitting connect event and/or calling the http2.connect callback.

http2session.destroy([error,][code])
	- error <Error> An Error object if the Http2Session is being destroyed due to an error.
	- code <number> The HTTP/2 error code to send in the final GOAWAY frame. If unspecified, and error is not undefined, the default is INTERNAL_ERROR, otherwise defaults to NO_ERROR.

http2session.destroyed
	Will be true if this Http2Session instance has been destroyed and must no longer be used, otherwise false.

http2session. Encrypted
	- Http2Session socket NOT connected – value undefined
	- Http2Session is connected in TLSSocket – true
	- Http2Session is connected to OTHER socket – false

http2session.goaway([code, [lastStreamID, [opaqueData]]])
	- code <number> An HTTP/2 error code
	- lastStreamID <number> The numeric ID of the last processed Http2Stream
	- opaqueData <Buffer> | <TypedArray> | <DataView> A TypedArray or DataView instance containing additional data to be carried within the GOAWAY frame.

Transmits a GOAWAY frame to the connected peer without shutting down the Http2Session.

http2session.localSettings
	A prototype-less object describing the current local settings of this Http2Session. The local settings are local to this Http2Session instance.

http2session.originSet
	If the Http2Session is connected to a TLSSocket, the originSet property will return an Array of origins for which the Http2Session may be considered authoritative.

http2session.pendingSettingsAck
	Acts as an indicator of Http2Session for a sent SETTINGS frames. Will be true after calling the http2session.settings() method. Will be false once all sent SETTINGS frames have been acknowledged.

http2session.ping([payload, ]callback)
	The callback will be invoked with three arguments: an error argument that will be null if the PING was successfully acknowledged, a duration argument that reports the number of milliseconds elapsed since the ping was sent and the acknowledgment was received, and a Buffer containing the 8-byte PING payload.

Sample Code

session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
  if (!err) {
    console.log(`Ping acknowledged in ${duration} milliseconds`);
    console.log(`With payload '${payload.toString()}'`);
  }});


http2session.ref()
	Calls ref() on this Http2Session instance's underlying net.Socket.

http2session.remoteSettings
	A prototype-less object describing the current remote settings of this Http2Session. The remote settings are set by the connected HTTP/2 peer.

http2session.setTimeout(msecs, callback)
	- msecs <number>
	- callback <Function>

Used to set a callback function that is called when there is no activity on the Http2Session after msecs milliseconds. The given callback is registered as a listener on the 'timeout' event.

http2session.socket
	Returns a Proxy object that acts as a net.Socket (or tls.TLSSocket) but limits available methods to ones safe to use with HTTP/2.

destroy, emit, end, pause, read, resume, and write will throw an error with code ERR_HTTP2_NO_SOCKET_MANIPULATION. Set Timeout method will be called on this Http2Session.

All other interactions will be routed directly to the socket.

http2session.state
	Provides miscellaneous information about the current state of the Http2Session.

<Object>
	- effectiveLocalWindowSize <number> The current local (receive) flow control window size for the Http2Session.
	- effectiveRecvDataLength <number> The current number of bytes that have been received since the last flow control WINDOW_UPDATE.
	- nextStreamID <number> The numeric identifier to be used the next time a new Http2Stream is created by this Http2Session.
	- localWindowSize <number> The number of bytes that the remote peer can send without receiving a WINDOW_UPDATE.
	- lastProcStreamID <number> The numeric id of the Http2Stream for which a HEADERS or DATA frame was most recently received.
 	- remoteWindowSize <number> The number of bytes that this Http2Session may send without receiving a WINDOW_UPDATE.
	- outboundQueueSize <number> The number of frames currently within the outbound queue for this Http2Session.
	- deflateDynamicTableSize <number> The current size in bytes of the outbound header compression state table.
	- inflateDynamicTableSize <number> The current size in bytes of the inbound header compression state table.

An object describing the current status of this Http2Session.

http2session.settings(settings)
	Updates the current local settings for this Http2Session and sends a new SETTINGS frame to the connected HTTP/2 peer. The SETTINGS will only be effective once it was received and acknowledged.

http2session.type
	The http2session.type will be equal to http2.constants.NGHTTP2_SESSION_SERVER if this Http2Session instance is a server, and http2.constants.NGHTTP2_SESSION_CLIENT if the instance is a client.

http2session.unref()
	Calls unref() on this Http2Session instance's underlying net.Socket

Class: ServerHttp2Session

Serverhttp2session.altsvc(alt,originOrStream)
	- alt <string> A description of the alternative service configuration as defined by RFC 7838.
	- originOrStream <number> | <string> | <URL> | <Object> Either a URL string specifying the origin (or an Object with an origin property) or the numeric identifier of an active Http2Stream as given by the http2stream.id property.

Submits an ALTSVC frame (as defined by RFC 7838) to the connected client.

Sample Code

const http2 = require('http2');
const server = http2.createServer();
server.on('session', (session) => {
  // Set altsvc for origin https://example.org:80
  session.altsvc('h2=":8000"', 'https://example.org:80');});

server.on('stream', (stream) => {
  // Set altsvc for a specific stream
  stream.session.altsvc('h2=":8000"', stream.id);});


Specifying alternative services
Described by RFC 7838 as an ASCII string, alt parameter format contains a comma-delimited list of “alternative” protocols related with a particular host and port.

Example: 
The value 'h2="example.org:81"' indicates that the HTTP/2 protocol is available on the host 'example.org' on TCP/IP port 81. The host and port must be contained within the quote (") characters.

Class: ClientHttp2Session

Event: ‘altsvc’
	- alt: <string>
	- origin: <string>
	- streamId: <number>

The 'altsvc' event is emitted whenever an ALTSVC frame is received by the client. The event is emitted with the ALTSVC value, origin, and stream ID. If no origin is provided in the ALTSVC frame, origin will be an empty string.

Sample Code

const http2 = require('http2');const client = http2.connect('https://example.org');

client.on('altsvc', (alt, origin, streamId) => {
  console.log(alt);
  console.log(origin);
  console.log(streamId);});


Clienthttp2session.request(headers[,options])
	- headers <HTTP/2 Headers Object>
	- options <Object>

	- If the Http2Stream writable side is initially closed, endstream <boolean> true.

	- Exclusive <boolean> when true and parent recognizes a parent Stream, Default: false.

	- parent <number> Specifies the numeric identifier of a stream the newly created stream is dependent on.
	- weight <number> Specifies the relative dependency of a stream in relation to other streams with the same parent

	- waitForTrailers <boolean> When true, the Http2Streamwill emit the 'wantTrailers' event after the final DATA frame has been sent.
	- HTTP/2 Client instances; http2session.request() creates and returns an Http2Stream instance that can be used to send an HTTP/2 request to the connected server.

Class: Http2Stream
	Each instance of the Http2Stream class represents a bidirectional HTTP/2 communications stream over an Http2Session instance. Any single Http2Session may have up to 231-1 Http2Stream instances over its lifetime.

Http2Stream Lifecycle

Creation
On the server side, instances of ServerHttp2Stream are created either when:

	- A new HTTP/2 HEADERS frame with a previously unused stream ID is received;
	- The http2stream.pushStream() method is called.

On the client side, instances of ClientHttp2Stream are created when the http2session.request() method is called.

Destruction
All Http2Stream instances are destroyed either when:

	- An RST_STREAM frame for the stream is received by the connected peer.
	- The http2stream.close() method is called.
	- The http2stream.destroy() or http2session.destroy() methods are called.

When an Http2Stream instance is destroyed, an attempt will be made to send an RST_STREAM frame will be sent to the connected peer.

Event: ‘aborted’
	The 'aborted' event is emitted whenever a Http2Stream instance is abnormally aborted in mid-communication, it will only be emitted if the Http2Stream writable side has not been ended.

Event: ‘close’
	The 'close' event is emitted when the Http2Stream is destroyed. Once this event is emitted, the Http2Stream instance is no longer usable.

Event: ‘error’
	The 'error' event is emitted when an error occurs during the processing of an Http2Stream.

Event: ‘frameError’
	The 'frameError' event is emitted when an error occurs while attempting to send a frame. When invoked, the handler function will receive an integer argument identifying the frame type, and an integer argument identifying the error code. The Http2Stream instance will be destroyed immediately after the 'frameError' event is emitted.

Event: ‘timeout’
	The 'timeout' event is emitted after no activity is received for this Http2Stream within the number of milliseconds set using http2stream.setTimeout().

Event: ‘trailers’
	The 'trailers' event is emitted when a block of headers associated with trailing header fields is received. The listener callback is passed the HTTP/2 Headers Object and flags associated with the headers.

Sample Code

stream.on('trailers', (headers, flags) => {
  console.log(headers);});


Event: ‘wantTrailers’
	This event is being released when Http2Stream queued the final DATA frame to be sent on a frame and is ready to send trailing headers. waitForTrailers must be set for this event to be released when asking for a response.

http2stream.aborted
Set to true if the Http2Stream instance was aborted abnormally. When set, the 'aborted' event will have been emitted.

http2stream.close(code[,callback])
	- code <number> Unsigned 32-bit integer identifying the error code. Default: http2.constants.NGHTTP2_NO_ERROR (0x00).
	- callback <Function> An optional function registered to listen for the 'close' event.

Closes the Http2Stream instance by sending an RST_STREAM frame to the connected HTTP/2 peer.

http2stream.closed
	Set to true if the Http2Stream instance has been closed.

http2stream.destroyed
	Set true if the Http2Stream instance has been destroyed and is no longer usable.

http2stream.pending
	Set to true if the Http2Stream instance has not yet been assigned a numeric stream identifier.

http2stream.priority(options)
	- options <object>
	- exclusive <boolean> When true and parent identifies a parent Stream, this stream is made the sole direct dependency of the parent, with all other existing dependents made a dependent of this stream. Default: false.
	- parent <number> Specifies the numeric identifier of a stream this stream is dependent on.
	- weight <number> Specifies the relative dependency of a stream in relation to other streams with the same parent. The value is a number between 1 and 256 (inclusive).
	- silent <boolean> When true, changes the priority locally without sending a PRIORITY frame to the connected peer.

Updates the priority for this Http2Stream instance.

http2stream.rstCode
	Set to the RST_STREAM error code reported when the Http2Stream is destroyed after either receiving an RST_STREAM frame from the connected peer, calling http2stream.close(), or http2stream.destroy(). Will be undefined if the Http2Stream has not been closed.

http2stream.sentHeaders
	An object containing the outbound headers sent for this Http2Stream.

http2stream.sentInfoHeaders
	An array of objects containing the outbound informational(additional) headers sent for this Http2Stream.

http2stream.sentTrailers
	An object containing the outbound trailers sent for this HttpStream.

http2stream.session
	A reference to the Http2Session instance that owns this Http2Stream. The value will be undefined after the Http2Stream instance is destroyed.

http2stream.setTimeout(msecs,callback)
	- msecs <number>
	- callback <Function>

Sample Code

const http2 = require('http2');const client = http2.connect('http://example.org:8000');const { NGHTTP2_CANCEL } = http2.constants;const req = client.request({ ':path': '/' });
// Cancel the stream if there's no activity after 5 seconds
req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));


http2stream.state
	Provides miscellaneous information about the current state of the Http2Stream.

	- <Object>
	- localWindowSize <number> The number of bytes the connected peer may send for this Http2Stream without receiving a WINDOW_UPDATE.
	- state <number> A flag indicating the low-level current state of the Http2Stream as determined by nghttp2.
	- localClose <number> true if this Http2Stream has been closed locally.
	- remoteClose <number> true if this Http2Stream has been closed remotely.
	- sumDependencyWeight <number> The sum weight of all Http2Stream instances that depend on this Http2Stream as specified using PRIORITY frames.
	- weight <number> The priority weight of this Http2Stream.

A current state of this Http2Stream.

http2stream.sendTrailers(headers)
	Sends a trailing HEADERS frame to the connected HTTP/2 peer. This method will cause the Http2Stream to be immediately closed and must only be called after the 'wantTrailers' event has been emitted. When sending a request or sending a response, the options.waitForTrailers option must be set in order to keep the Http2Stream open after the final DATA frame so that trailers can be sent.

Sample Code

const http2 = require('http2');const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respond(undefined, { waitForTrailers: true });
  stream.on('wantTrailers', () => {
    stream.sendTrailers({ xyz: 'abc' });
  });
  stream.end('Hello World');});


Class: ClientHttp2Stream
	The ClientHttp2Stream class is an extension of Http2Stream that is used exclusively on HTTP/2 Clients. Http2Stream instances on the client provide events such as 'response' and 'push' that are only relevant on the client.

Event: ‘continue’
	Emitted when the server sends a 100 Continue status, usually because the request contained Expect: 100-continue. This is an instruction that the client should send the request body.

Event: ‘headers’
	The 'headers' event is emitted when an additional block of headers is received for a stream, such as when a block of 1xx informational headers is received. The listener callback is passed the HTTP/2 Headers Object and flags associated with the headers.

Sample Code

stream.on('headers', (headers, flags) => {
  console.log(headers);});

Event: ‘push’
	The 'push' event is emitted when response headers for a Server Push stream are received. The listener callback is passed the HTTP/2 Headers Object and flags associated with the headers.

Sample Code

stream.on('push', (headers, flags) => {
  console.log(headers);});

Event: ‘response’
	The 'response' event is emitted when a response HEADERS frame has been received for this stream from the connected HTTP/2 server. The listener is invoked with two arguments: an Object containing the received HTTP/2 Headers Object, and flags associated with the headers.

Sample Code

const http2 = require('http2');const client = http2.connect('https://localhost');const req = client.request({ ':path': '/' });
req.on('response', (headers, flags) => {
  console.log(headers[':status']);});

Class: ServerHttp2Stream
	It is an extension of Http2Stream exclusively for HTTP/2 Servers. Also provides additional methods like http2stream.pushStream() and http2stream.respond() that are only relevant on the server.

http2stream.additionalHeaders(headers)
	Sends additional informational HEADERS frame tp the connected HTTP/2 peer.

http2stream.headersSent
	Boolean(read-only). True if headers were sent, false if not.

http2stream.pushAllowed
	Read-only property mapped to the SETTINGS_ENABLE_PUSH flag of the remote client's most recent SETTINGS frame. Will be true if the remote peer accepts push streams, false otherwise. Settings are the same for every Http2Stream in the same Http2Session.

http2stream.pushStream(headers[,options],callback)
	- headers <HTTP/2 Headers Object>
	- options <Object>
exclusive <boolean> When true and parent identifies a parent Stream, the created stream is made the sole direct dependency of the parent, with all other existing dependents made a dependent of the newly created stream. Default: false.

parent <number> Specifies the numeric identifier of a stream the newly created stream is dependent on.
	- callback <Function> Callback that is called once the push stream has been initiated.
err <Error>

pushStream <ServerHttp2Stream> The returned pushStream object.

headers <HTTP/2 Headers Object> Headers object the pushStream was initiated with.

http2stream.respond([headers[,options]])
	When the options.waitForTrailers option is set, the 'wantTrailers' event will be emitted immediately after queuing the last chunk of payload data to be sent. The http2stream.sendTrailers() method can then be used to sent trailing header fields to the peer.

http2stream.respondWithFD(fd[,headers[,options]])
	- fd <number> A readable file descriptor.
	- headers HTTP/2 Headers Object>
	- options <Object>

statCheck <Function>

waitForTrailers <boolean> When true, the Http2Stream will emit the 'wantTrailers' event after the final DATA frame has been sent.

offset <number> The offset position at which to begin reading.

length <number> The amount of data from the fd to send.

http2stream.respondWithFile(path[,headers[,options]])
	- path <string> | <Buffer> | <URL>
	- headers <HTTP/2 Headers Object>
	- options <Object>

statCheck <Function>

onError <Function> Callback function invoked in the case of an Error before send.

waitForTrailers <boolean> When true, the Http2Stream will emit the 'wantTrailers' event after the final DATA frame has been sent.

offset <number> The offset position at which to begin reading.

length <number> The amount of data from the fd to send.

Class: Http2Server
	In Http2Server, there are no 'clientError' events as there are in HTTP1. However, there are 'sessionError', and 'streamError' events for errors emitted on the socket, or from Http2Session or Http2Stream instances.

Event: ‘checkContinue’
	If a 'request' listener is registered or http2.createServer() is supplied a callback function, the 'checkContinue' event is emitted each time a request with an HTTP Expect: 100-continue is received. If this event is not listened for, the server will automatically respond with a status 100 Continue as appropriate.

Handling this event involves calling response.writeContinue() if the client should continue to send the request body, or generating an appropriate HTTP response (e.g. 400 Bad Request) if the client should not continue to send the request body.

Event: ‘request’
	- request <http2.Http2ServerRequest>
	- response <http2.Http2ServerResponse>
Emitted each time there is a request. Note that there may be multiple requests per session. See the Compatibility API.

Event: ‘session’
	The ‘session’ event is emitted when a new Http2Session is created by the Http2Server

Event: ‘sessionError
	The 'sessionError' event is emitted when an 'error' event is emitted by an Http2Session object associated with the Http2Server.

Event: ‘streamError’
	If a ServerHttp2Stream emits an 'error' event, it will be forwarded here. The stream will already be destroyed when this event is triggered.

Event: ‘stream’
	The 'stream' event is emitted when a 'stream' event has been emitted by an Http2Session associated with the server.

Event: ‘timeout’
	The 'timeout' event is emitted when there is no activity on the Server for a given number of milliseconds set using http2server.setTimeout().

server.close([callback])
	- callback <Function>
Stops the server from accepting new connections. See net.Server.close().

*Note that this is not analogous to restricting new requests since HTTP/2 connections are persistent. To achieve a similar graceful shutdown behavior, consider also using http2session.close() on active sessions.

Class: Http2SecureServer
	- Extends: <tls.Server>

Event: ‘checkContinue’
	If a 'request' listener is registered or http2.createSecureServer() is supplied a callback function, the 'checkContinue' event is emitted each time a request with an HTTP Expect: 100-continue is received. If this event is not listened for, the server will automatically respond with a status 100 Continue as appropriate.

Handling this event involves calling response.writeContinue() if the client should continue to send the request body, or generating an appropriate HTTP response (e.g. 400 Bad Request) if the client should not continue to send the request body.

Event: ‘request’
	- request <http2.Http2ServerRequest>
	- response <http2.Http2ServerResponse>
Emitted each time there is a request. Note that there may be multiple requests per session. See the Compatibility API.

Event: ‘session’
	The 'session' event is emitted when a new Http2Session is created by the Http2SecureServer.

Event: ‘sessionError’
	The 'sessionError' event is emitted when an 'error' event is emitted by an Http2Session object associated with the Http2SecureServer.

Event: ‘stream’
	The 'stream' event is emitted when a 'stream' event has been emitted by an Http2Session associated with the server.

Sample Code

const http2 = require('http2');const {
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_CONTENT_TYPE} = http2.constants;
const options = getOptionsSomehow();
const server = http2.createSecureServer(options);
server.on('stream', (stream, headers, flags) => {
  const method = headers[HTTP2_HEADER_METHOD];
  const path = headers[HTTP2_HEADER_PATH];
  // ...
  stream.respond({
    [HTTP2_HEADER_STATUS]: 200,
    [HTTP2_HEADER_CONTENT_TYPE]: 'text/plain'
  });
  stream.write('hello ');
  stream.end('world');});


Event: ‘timeout’
	The 'timeout' event is emitted when there is no activity on the Server for a given number of milliseconds set using http2secureServer.setTimeout().

Event: ‘unknownProtocol’
	The event handler receives the socket for handling. If no listener is registered for this event, the connection is terminated. See the Compatibility API.

Server.close([callback])
	- callback <Function>
Stops the server from accepting new connections. See tls.Server.close().

*Note that this is not analogous to restricting new requests since HTTP/2 connections are persistent. To achieve a similar graceful shutdown behavior, consider also using http2session.close() on active sessions.


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	